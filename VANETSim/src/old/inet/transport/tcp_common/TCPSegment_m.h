//
// Generated file, do not edit! Created by nedtool 4.6 from inet/transport/tcp_common/TCPSegment.msg.
//

#ifndef _TCPSEGMENT_M_H_
#define _TCPSEGMENT_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <iostream>
#include "INETDefs.h"
#include "ByteArray.h"

    // default TCP header length: 20 bytes
    #define TCP_HEADER_OCTETS  20    // without options

    // maximum TCP header length (base + options): 60 = 4 * 15 bytes
    const unsigned int TCP_MAX_HEADER_OCTETS = 60;

    // maximum allowed sack entry number, if no other options are used
    const unsigned int MAX_SACK_ENTRIES = 4;

    typedef cPacket *cPacketPtr;

    inline std::ostream& operator<<(std::ostream& os, cPacketPtr msg)
    {
        return os << "(" << msg->getClassName() << ") " << msg->getName() << ": " << msg->info();
    }

    inline void doPacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimPack(b);}
    inline void doUnpacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimUnpack(b);}
// }}

/**
 * Struct generated from inet/transport/tcp_common/TCPSegment.msg:50 by nedtool.
 */
struct TCPPayloadMessage
{
    TCPPayloadMessage();
    unsigned int endSequenceNo;
    cPacketPtr msg;
};

void doPacking(cCommBuffer *b, TCPPayloadMessage& a);
void doUnpacking(cCommBuffer *b, TCPPayloadMessage& a);

/**
 * Enum generated from <tt>inet/transport/tcp_common/TCPSegment.msg:63</tt> by nedtool.
 * <pre>
 * //
 * // TCP Option Numbers
 * // Reference: http://www.iana.org/assignments/tcp-parameters/
 * // Date: 2011-07-02
 * //
 * // Note: Options not yet implemented should stay commented out
 * //
 * enum TCPOptionNumbers
 * {
 * 
 *     TCPOPTION_END_OF_OPTION_LIST = 0;                   // RFC 793, LENGTH: 1 Byte
 *     TCPOPTION_NO_OPERATION = 1;                         // RFC 793, LENGTH: 1 Byte
 *     TCPOPTION_MAXIMUM_SEGMENT_SIZE = 2;                 // RFC 793, LENGTH: 4 Bytes
 *     TCPOPTION_WINDOW_SCALE = 3;                         // RFC 1323, LENGTH: 3 Bytes
 *     TCPOPTION_SACK_PERMITTED = 4;                       // RFC 2018, LENGTH: 2 Bytes
 *     TCPOPTION_SACK = 5;                                 // RFC 2018, LENGTH: N (max. N = 4) 8 * n + 2 Bytes  => 32 + 2 + 2 * NOP = 36 Bytes; If TIMESTAMP option is used with SACK: max. n = 3 => 12 Bytes (for Timestamp) + 28 Bytes (for SACK) = 40 Bytes
 *     //    TCPOPTION_ECHO = 6;                               // (obsoleted by option 8) RFC 1072 & RFC 6247, LENGTH: 6 Bytes
 *     //    TCPOPTION_ECHO_REPLY = 7;                         // (obsoleted by option 8) RFC 1072 & RFC 6247, LENGTH: 6 Bytes
 *     TCPOPTION_TIMESTAMP = 8;                            // RFC 1323, LENGTH: 10 Bytes
 * }
 * </pre>
 */
enum TCPOptionNumbers {
    TCPOPTION_END_OF_OPTION_LIST = 0,
    TCPOPTION_NO_OPERATION = 1,
    TCPOPTION_MAXIMUM_SEGMENT_SIZE = 2,
    TCPOPTION_WINDOW_SCALE = 3,
    TCPOPTION_SACK_PERMITTED = 4,
    TCPOPTION_SACK = 5,
    TCPOPTION_TIMESTAMP = 8
};

/**
 * Class generated from <tt>inet/transport/tcp_common/TCPSegment.msg:103</tt> by nedtool.
 * <pre>
 * //
 * // This structure represents a single SACK (selective acknowledgment):
 * //
 * class Sack
 * {
 *     @customize(true);
 *     unsigned int start;     // start seq no. of sack block
 *     unsigned int end;       // end seq no. of sack block
 * }
 * </pre>
 *
 * Sack_Base is only useful if it gets subclassed, and Sack is derived from it.
 * The minimum code to be written for Sack is the following:
 *
 * <pre>
 * class Sack : public Sack_Base
 * {
 *   private:
 *     void copy(const Sack& other) { ... }

 *   public:
 *     Sack() : Sack_Base() {}
 *     Sack(const Sack& other) : Sack_Base(other) {copy(other);}
 *     Sack& operator=(const Sack& other) {if (this==&other) return *this; Sack_Base::operator=(other); copy(other); return *this;}
 *     virtual Sack *dup() const {return new Sack(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from Sack_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(Sack);
 * </pre>
 */
class Sack_Base : public ::cObject
{
  protected:
    unsigned int start_var;
    unsigned int end_var;

  private:
    void copy(const Sack_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Sack_Base&);
    // make constructors protected to avoid instantiation
    Sack_Base();
    Sack_Base(const Sack_Base& other);
    // make assignment operator protected to force the user override it
    Sack_Base& operator=(const Sack_Base& other);

  public:
    virtual ~Sack_Base();
    virtual Sack_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class Sack");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getStart() const;
    virtual void setStart(unsigned int start);
    virtual unsigned int getEnd() const;
    virtual void setEnd(unsigned int end);
};

/**
 * Class generated from <tt>inet/transport/tcp_common/TCPSegment.msg:111</tt> by nedtool.
 * <pre>
 * // Header Options (optional):
 * class TCPOption
 * {
 *     unsigned short kind @enum(TCPOptionNumbers) = TCPOPTION_END_OF_OPTION_LIST;  // option kind
 *     unsigned short length = 1;                          // option length
 *     unsigned int values[];                              // option value(s)
 * }
 * </pre>
 */
class TCPOption : public ::cObject
{
  protected:
    unsigned short kind_var;
    unsigned short length_var;
    unsigned int *values_var; // array ptr
    unsigned int values_arraysize;

  private:
    void copy(const TCPOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TCPOption&);

  public:
    TCPOption();
    TCPOption(const TCPOption& other);
    virtual ~TCPOption();
    TCPOption& operator=(const TCPOption& other);
    virtual TCPOption *dup() const {return new TCPOption(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getKind() const;
    virtual void setKind(unsigned short kind);
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
    virtual void setValuesArraySize(unsigned int size);
    virtual unsigned int getValuesArraySize() const;
    virtual unsigned int getValues(unsigned int k) const;
    virtual void setValues(unsigned int k, unsigned int values);
};

inline void doPacking(cCommBuffer *b, TCPOption& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, TCPOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transport/tcp_common/TCPSegment.msg:132</tt> by nedtool.
 * <pre>
 * //
 * // Represents a TCP segment, to be used with the ~TCP module.
 * //
 * // TCP header fields not explicitly modelled: work on going
 * // - Data Offset (number of 32 bit words in the header): represented
 * //   by cMessage::length().
 * // - Reserved (reserved for future use)
 * // - Checksum (header checksum): modelled by cMessage::hasBitError()
 * // - Header Options: Currently only EOL, NOP, MSS, WS, SACK_PERMITTED, SACK and TS are implemented
 * // - Padding
 * //
 * // cMessage::getKind() may be set to an arbitrary value: TCP entities will
 * // ignore it and use only the header fields (synBit, ackBit, rstBit).
 * //
 * packet TCPSegment
 * {
 *     @customize(true);
 *     // Source Port
 *     unsigned short srcPort;
 * 
 *     // Destination Port
 *     unsigned short destPort;
 * 
 *     // Sequence Number: first sequence number of the first data octet
 *     // in the respective segment (except if SYN is set; then the the
 *     // seq. number is the initial seq. number (ISS) and the first data
 *     // octet is ISS + 1)
 *     unsigned int sequenceNo;
 * 
 *     // Acknowledgement Number: if ACK flag is set, this field contains
 *     // the next sequence number the sender of this segment is expecting
 *     // to receive
 *     unsigned int ackNo;
 * 
 *     // TCP Header Length - default: 20 bytes
 *     // if header options are used the headerLength is greater than 20 bytes (default)
 *     unsigned short headerLength = TCP_HEADER_OCTETS; // TCP_HEADER_OCTETS = 20
 * 
 *     bool urgBit; // URG: urgent pointer field significant if set
 *     bool ackBit; // ACK: ackNo significant if set
 *     bool pshBit; // PSH: push function
 *     bool rstBit; // RST: reset the connection
 *     bool synBit; // SYN: synchronize seq. numbers
 *     bool finBit; // FIN: finish - no more data from sender
 * 
 *     // Window Size: the number of data octets beginning with the one indicated
 *     // in the acknowledgement field which the sender of this segment is
 *     // willing to accept
 *     unsigned short window;
 * 
 *     // Urgent Pointer: communicates the current value of the urgent pointer
 *     // as a positive offset from the sequence number in this segment. The
 *     // urgent pointer points to the sequence number of the octet following
 *     // the urgent data. This field is only be interpreted in segments with
 *     // the URG control bit set.
 *     unsigned short urgentPointer;
 * 
 *     // Header options (optional)
 *     // Currently only EOL, NOP, MSS, WS, SACK_PERMITTED, SACK and TS are implemented
 *     TCPOption options[];
 * 
 *     // Payload length in octets (not an actual TCP header field).
 *     // This may not always be the same as encapsulatedPacket()->getByteLength();
 *     // e.g. when simulating a virtual data stream there's no encapsulated
 *     // packet at all.
 *     unsigned long payloadLength;
 * 
 *     // Message objects (cMessages) that travel in this segment as data.
 *     // This field is used only when the ~TCPDataTransferMode is TCP_TRANSFER_OBJECT.
 *     // Every message object is put into the TCPSegment that would (in real life)
 *     // carry its first octet. That is, if message object 'msg' with length=100 bytes
 *     // occupies stream offset number range 10000..10099, it will travel in the
 *     // TCPSegment which carries the octet 10000. This way it is easily achieved
 *     // that the receiving TCP passes up the message object to its client
 *     // when the last byte of the message has arrived.
 *     abstract TCPPayloadMessage payload[];
 * 
 *     // Message bytes that travel in this segment as data.
 *     // This field is used only when the ~TCPDataTransferMode is TCP_TRANSFER_BYTESTREAM.
 *     ByteArray byteArray;
 * }
 * </pre>
 *
 * TCPSegment_Base is only useful if it gets subclassed, and TCPSegment is derived from it.
 * The minimum code to be written for TCPSegment is the following:
 *
 * <pre>
 * class TCPSegment : public TCPSegment_Base
 * {
 *   private:
 *     void copy(const TCPSegment& other) { ... }

 *   public:
 *     TCPSegment(const char *name=NULL, int kind=0) : TCPSegment_Base(name,kind) {}
 *     TCPSegment(const TCPSegment& other) : TCPSegment_Base(other) {copy(other);}
 *     TCPSegment& operator=(const TCPSegment& other) {if (this==&other) return *this; TCPSegment_Base::operator=(other); copy(other); return *this;}
 *     virtual TCPSegment *dup() const {return new TCPSegment(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from TCPSegment_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(TCPSegment);
 * </pre>
 */
class TCPSegment_Base : public ::cPacket
{
  protected:
    unsigned short srcPort_var;
    unsigned short destPort_var;
    unsigned int sequenceNo_var;
    unsigned int ackNo_var;
    unsigned short headerLength_var;
    bool urgBit_var;
    bool ackBit_var;
    bool pshBit_var;
    bool rstBit_var;
    bool synBit_var;
    bool finBit_var;
    unsigned short window_var;
    unsigned short urgentPointer_var;
    TCPOption *options_var; // array ptr
    unsigned int options_arraysize;
    unsigned long payloadLength_var;
    ByteArray byteArray_var;

  private:
    void copy(const TCPSegment_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TCPSegment_Base&);
    // make constructors protected to avoid instantiation
    TCPSegment_Base(const char *name=NULL, int kind=0);
    TCPSegment_Base(const TCPSegment_Base& other);
    // make assignment operator protected to force the user override it
    TCPSegment_Base& operator=(const TCPSegment_Base& other);

  public:
    virtual ~TCPSegment_Base();
    virtual TCPSegment_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class TCPSegment");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getSrcPort() const;
    virtual void setSrcPort(unsigned short srcPort);
    virtual unsigned short getDestPort() const;
    virtual void setDestPort(unsigned short destPort);
    virtual unsigned int getSequenceNo() const;
    virtual void setSequenceNo(unsigned int sequenceNo);
    virtual unsigned int getAckNo() const;
    virtual void setAckNo(unsigned int ackNo);
    virtual unsigned short getHeaderLength() const;
    virtual void setHeaderLength(unsigned short headerLength);
    virtual bool getUrgBit() const;
    virtual void setUrgBit(bool urgBit);
    virtual bool getAckBit() const;
    virtual void setAckBit(bool ackBit);
    virtual bool getPshBit() const;
    virtual void setPshBit(bool pshBit);
    virtual bool getRstBit() const;
    virtual void setRstBit(bool rstBit);
    virtual bool getSynBit() const;
    virtual void setSynBit(bool synBit);
    virtual bool getFinBit() const;
    virtual void setFinBit(bool finBit);
    virtual unsigned short getWindow() const;
    virtual void setWindow(unsigned short window);
    virtual unsigned short getUrgentPointer() const;
    virtual void setUrgentPointer(unsigned short urgentPointer);
    virtual void setOptionsArraySize(unsigned int size);
    virtual unsigned int getOptionsArraySize() const;
    virtual TCPOption& getOptions(unsigned int k);
    virtual const TCPOption& getOptions(unsigned int k) const {return const_cast<TCPSegment_Base*>(this)->getOptions(k);}
    virtual void setOptions(unsigned int k, const TCPOption& options);
    virtual unsigned long getPayloadLength() const;
    virtual void setPayloadLength(unsigned long payloadLength);
    virtual void setPayloadArraySize(unsigned int size) = 0;
    virtual unsigned int getPayloadArraySize() const = 0;
    virtual TCPPayloadMessage& getPayload(unsigned int k) = 0;
    virtual const TCPPayloadMessage& getPayload(unsigned int k) const {return const_cast<TCPSegment_Base*>(this)->getPayload(k);}
    virtual void setPayload(unsigned int k, const TCPPayloadMessage& payload) = 0;
    virtual ByteArray& getByteArray();
    virtual const ByteArray& getByteArray() const {return const_cast<TCPSegment_Base*>(this)->getByteArray();}
    virtual void setByteArray(const ByteArray& byteArray);
};


#endif // ifndef _TCPSEGMENT_M_H_

