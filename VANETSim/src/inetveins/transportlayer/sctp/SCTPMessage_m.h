//
// Generated file, do not edit! Created by nedtool 4.6 from inetveins/transportlayer/sctp/SCTPMessage.msg.
//

#ifndef _INETVEINS__SCTP_SCTPMESSAGE_M_H_
#define _INETVEINS__SCTP_SCTPMESSAGE_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inetveins/networklayer/common/L3Address.h"
// }}


namespace inetveins {
namespace sctp {

// cplusplus {{
typedef cPacket *cPacketPtr;
// }}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:36</tt> by nedtool.
 * <pre>
 * message SCTPMessage extends cPacket
 * {
 *     @customize(true);
 *     // Source Port
 *     uint16 srcPort;
 *     // Destination Port
 *     uint16 destPort;
 *     // Verification Tag
 *     uint32 tag;
 *     bool checksumOk;
 *     abstract cPacketPtr chunks[];
 * }
 * </pre>
 *
 * SCTPMessage_Base is only useful if it gets subclassed, and SCTPMessage is derived from it.
 * The minimum code to be written for SCTPMessage is the following:
 *
 * <pre>
 * class SCTPMessage : public SCTPMessage_Base
 * {
 *   private:
 *     void copy(const SCTPMessage& other) { ... }

 *   public:
 *     SCTPMessage(const char *name=NULL, int kind=0) : SCTPMessage_Base(name,kind) {}
 *     SCTPMessage(const SCTPMessage& other) : SCTPMessage_Base(other) {copy(other);}
 *     SCTPMessage& operator=(const SCTPMessage& other) {if (this==&other) return *this; SCTPMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPMessage *dup() const {return new SCTPMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPMessage);
 * </pre>
 */
class SCTPMessage_Base : public ::cPacket
{
  protected:
    uint16 srcPort_var;
    uint16 destPort_var;
    uint32 tag_var;
    bool checksumOk_var;

  private:
    void copy(const SCTPMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPMessage_Base&);
    // make constructors protected to avoid instantiation
    SCTPMessage_Base(const char *name=NULL, int kind=0);
    SCTPMessage_Base(const SCTPMessage_Base& other);
    // make assignment operator protected to force the user override it
    SCTPMessage_Base& operator=(const SCTPMessage_Base& other);

  public:
    virtual ~SCTPMessage_Base();
    virtual SCTPMessage_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class SCTPMessage");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16 getSrcPort() const;
    virtual void setSrcPort(uint16 srcPort);
    virtual uint16 getDestPort() const;
    virtual void setDestPort(uint16 destPort);
    virtual uint32 getTag() const;
    virtual void setTag(uint32 tag);
    virtual bool getChecksumOk() const;
    virtual void setChecksumOk(bool checksumOk);
    virtual void setChunksArraySize(unsigned int size) = 0;
    virtual unsigned int getChunksArraySize() const = 0;
    virtual cPacketPtr& getChunks(unsigned int k) = 0;
    virtual const cPacketPtr& getChunks(unsigned int k) const {return const_cast<SCTPMessage_Base*>(this)->getChunks(k);}
    virtual void setChunks(unsigned int k, const cPacketPtr& chunks) = 0;
};

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:50</tt> by nedtool.
 * <pre>
 * message SCTPChunk extends cPacket
 * {
 *     @customize(false);
 *     // Chunk Type
 *     uint8 chunkType;
 * }
 * </pre>
 */
class SCTPChunk : public ::cPacket
{
  protected:
    uint8 chunkType_var;

  private:
    void copy(const SCTPChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPChunk&);

  public:
    SCTPChunk(const char *name=NULL, int kind=0);
    SCTPChunk(const SCTPChunk& other);
    virtual ~SCTPChunk();
    SCTPChunk& operator=(const SCTPChunk& other);
    virtual SCTPChunk *dup() const {return new SCTPChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8 getChunkType() const;
    virtual void setChunkType(uint8 chunkType);
};

inline void doPacking(cCommBuffer *b, SCTPChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:57</tt> by nedtool.
 * <pre>
 * message SCTPInitChunk extends SCTPChunk
 * {
 *     // Initiate Tag
 *     uint32 initTag;
 *     // Advertised Receiver Window
 *     uint32 a_rwnd;
 *     // Number of Outbound Streams
 *     uint16 noOutStreams;
 *     // Number of Inbound Streams
 *     uint16 noInStreams;
 *     // Initial TSN
 *     uint32 initTSN;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     uint8 unrecognizedParameters[]; //Will be filled by the Parser, if unrecognized Parameters arrive.
 *     uint32 msg_rwnd;
 *     uint16 chunkTypes[]; //Chunk list parameter, i.e. for SCTP AUTH
 *     uint16 sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16 hmacTypes[]; //HMAC Identifier for HMAC algorithm parameter
 *     uint8 random[]; //Random Parameter for SCTP AUTH
 * }
 * </pre>
 */
class SCTPInitChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 initTag_var;
    uint32 a_rwnd_var;
    uint16 noOutStreams_var;
    uint16 noInStreams_var;
    uint32 initTSN_var;
    bool forwardTsn_var;
    bool ipv4Supported_var;
    bool ipv6Supported_var;
    L3Address *addresses_var; // array ptr
    unsigned int addresses_arraysize;
    uint8 *unrecognizedParameters_var; // array ptr
    unsigned int unrecognizedParameters_arraysize;
    uint32 msg_rwnd_var;
    uint16 *chunkTypes_var; // array ptr
    unsigned int chunkTypes_arraysize;
    uint16 *sepChunks_var; // array ptr
    unsigned int sepChunks_arraysize;
    uint16 *hmacTypes_var; // array ptr
    unsigned int hmacTypes_arraysize;
    uint8 *random_var; // array ptr
    unsigned int random_arraysize;

  private:
    void copy(const SCTPInitChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPInitChunk&);

  public:
    SCTPInitChunk(const char *name=NULL, int kind=0);
    SCTPInitChunk(const SCTPInitChunk& other);
    virtual ~SCTPInitChunk();
    SCTPInitChunk& operator=(const SCTPInitChunk& other);
    virtual SCTPInitChunk *dup() const {return new SCTPInitChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getInitTag() const;
    virtual void setInitTag(uint32 initTag);
    virtual uint32 getA_rwnd() const;
    virtual void setA_rwnd(uint32 a_rwnd);
    virtual uint16 getNoOutStreams() const;
    virtual void setNoOutStreams(uint16 noOutStreams);
    virtual uint16 getNoInStreams() const;
    virtual void setNoInStreams(uint16 noInStreams);
    virtual uint32 getInitTSN() const;
    virtual void setInitTSN(uint32 initTSN);
    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);
    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);
    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);
    virtual void setAddressesArraySize(unsigned int size);
    virtual unsigned int getAddressesArraySize() const;
    virtual L3Address& getAddresses(unsigned int k);
    virtual const L3Address& getAddresses(unsigned int k) const {return const_cast<SCTPInitChunk*>(this)->getAddresses(k);}
    virtual void setAddresses(unsigned int k, const L3Address& addresses);
    virtual void setUnrecognizedParametersArraySize(unsigned int size);
    virtual unsigned int getUnrecognizedParametersArraySize() const;
    virtual uint8 getUnrecognizedParameters(unsigned int k) const;
    virtual void setUnrecognizedParameters(unsigned int k, uint8 unrecognizedParameters);
    virtual uint32 getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32 msg_rwnd);
    virtual void setChunkTypesArraySize(unsigned int size);
    virtual unsigned int getChunkTypesArraySize() const;
    virtual uint16 getChunkTypes(unsigned int k) const;
    virtual void setChunkTypes(unsigned int k, uint16 chunkTypes);
    virtual void setSepChunksArraySize(unsigned int size);
    virtual unsigned int getSepChunksArraySize() const;
    virtual uint16 getSepChunks(unsigned int k) const;
    virtual void setSepChunks(unsigned int k, uint16 sepChunks);
    virtual void setHmacTypesArraySize(unsigned int size);
    virtual unsigned int getHmacTypesArraySize() const;
    virtual uint16 getHmacTypes(unsigned int k) const;
    virtual void setHmacTypes(unsigned int k, uint16 hmacTypes);
    virtual void setRandomArraySize(unsigned int size);
    virtual unsigned int getRandomArraySize() const;
    virtual uint8 getRandom(unsigned int k) const;
    virtual void setRandom(unsigned int k, uint8 random);
};

inline void doPacking(cCommBuffer *b, SCTPInitChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPInitChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:81</tt> by nedtool.
 * <pre>
 * message SCTPInitAckChunk extends SCTPChunk
 * {
 *     // Initiate Tag
 *     uint32 initTag;
 *     // Advertised Receiver Window
 *     uint32 a_rwnd;
 *     // Number of Outbound Streams
 *     uint16 noOutStreams;
 *     // Number of Inbound Streams
 *     uint16 noInStreams;
 *     // Initial TSN
 *     uint32 initTSN;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     char cookie[];
 *     uint8 unrecognizedParameters[];
 *     cPacketPtr stateCookie = nullptr;
 *     uint32 msg_rwnd;
 *     uint8 random[]; //Random Number
 *     uint16 chunkTypes[];
 *     uint16 sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16 hmacTypes[];
 * }
 * </pre>
 */
class SCTPInitAckChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 initTag_var;
    uint32 a_rwnd_var;
    uint16 noOutStreams_var;
    uint16 noInStreams_var;
    uint32 initTSN_var;
    bool forwardTsn_var;
    bool ipv4Supported_var;
    bool ipv6Supported_var;
    L3Address *addresses_var; // array ptr
    unsigned int addresses_arraysize;
    char *cookie_var; // array ptr
    unsigned int cookie_arraysize;
    uint8 *unrecognizedParameters_var; // array ptr
    unsigned int unrecognizedParameters_arraysize;
    cPacketPtr stateCookie_var;
    uint32 msg_rwnd_var;
    uint8 *random_var; // array ptr
    unsigned int random_arraysize;
    uint16 *chunkTypes_var; // array ptr
    unsigned int chunkTypes_arraysize;
    uint16 *sepChunks_var; // array ptr
    unsigned int sepChunks_arraysize;
    uint16 *hmacTypes_var; // array ptr
    unsigned int hmacTypes_arraysize;

  private:
    void copy(const SCTPInitAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPInitAckChunk&);

  public:
    SCTPInitAckChunk(const char *name=NULL, int kind=0);
    SCTPInitAckChunk(const SCTPInitAckChunk& other);
    virtual ~SCTPInitAckChunk();
    SCTPInitAckChunk& operator=(const SCTPInitAckChunk& other);
    virtual SCTPInitAckChunk *dup() const {return new SCTPInitAckChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getInitTag() const;
    virtual void setInitTag(uint32 initTag);
    virtual uint32 getA_rwnd() const;
    virtual void setA_rwnd(uint32 a_rwnd);
    virtual uint16 getNoOutStreams() const;
    virtual void setNoOutStreams(uint16 noOutStreams);
    virtual uint16 getNoInStreams() const;
    virtual void setNoInStreams(uint16 noInStreams);
    virtual uint32 getInitTSN() const;
    virtual void setInitTSN(uint32 initTSN);
    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);
    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);
    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);
    virtual void setAddressesArraySize(unsigned int size);
    virtual unsigned int getAddressesArraySize() const;
    virtual L3Address& getAddresses(unsigned int k);
    virtual const L3Address& getAddresses(unsigned int k) const {return const_cast<SCTPInitAckChunk*>(this)->getAddresses(k);}
    virtual void setAddresses(unsigned int k, const L3Address& addresses);
    virtual void setCookieArraySize(unsigned int size);
    virtual unsigned int getCookieArraySize() const;
    virtual char getCookie(unsigned int k) const;
    virtual void setCookie(unsigned int k, char cookie);
    virtual void setUnrecognizedParametersArraySize(unsigned int size);
    virtual unsigned int getUnrecognizedParametersArraySize() const;
    virtual uint8 getUnrecognizedParameters(unsigned int k) const;
    virtual void setUnrecognizedParameters(unsigned int k, uint8 unrecognizedParameters);
    virtual cPacketPtr& getStateCookie();
    virtual const cPacketPtr& getStateCookie() const {return const_cast<SCTPInitAckChunk*>(this)->getStateCookie();}
    virtual void setStateCookie(const cPacketPtr& stateCookie);
    virtual uint32 getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32 msg_rwnd);
    virtual void setRandomArraySize(unsigned int size);
    virtual unsigned int getRandomArraySize() const;
    virtual uint8 getRandom(unsigned int k) const;
    virtual void setRandom(unsigned int k, uint8 random);
    virtual void setChunkTypesArraySize(unsigned int size);
    virtual unsigned int getChunkTypesArraySize() const;
    virtual uint16 getChunkTypes(unsigned int k) const;
    virtual void setChunkTypes(unsigned int k, uint16 chunkTypes);
    virtual void setSepChunksArraySize(unsigned int size);
    virtual unsigned int getSepChunksArraySize() const;
    virtual uint16 getSepChunks(unsigned int k) const;
    virtual void setSepChunks(unsigned int k, uint16 sepChunks);
    virtual void setHmacTypesArraySize(unsigned int size);
    virtual unsigned int getHmacTypesArraySize() const;
    virtual uint16 getHmacTypes(unsigned int k) const;
    virtual void setHmacTypes(unsigned int k, uint16 hmacTypes);
};

inline void doPacking(cCommBuffer *b, SCTPInitAckChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPInitAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:109</tt> by nedtool.
 * <pre>
 * message SCTPCookieEchoChunk extends SCTPChunk
 * {
 *     char cookie[];
 *     cPacketPtr stateCookie = nullptr;
 *     uint8 unrecognizedParameters[]; //for the serializer to send an Error chunk bundled with a Cookie-Echo
 * }
 * </pre>
 */
class SCTPCookieEchoChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    char *cookie_var; // array ptr
    unsigned int cookie_arraysize;
    cPacketPtr stateCookie_var;
    uint8 *unrecognizedParameters_var; // array ptr
    unsigned int unrecognizedParameters_arraysize;

  private:
    void copy(const SCTPCookieEchoChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPCookieEchoChunk&);

  public:
    SCTPCookieEchoChunk(const char *name=NULL, int kind=0);
    SCTPCookieEchoChunk(const SCTPCookieEchoChunk& other);
    virtual ~SCTPCookieEchoChunk();
    SCTPCookieEchoChunk& operator=(const SCTPCookieEchoChunk& other);
    virtual SCTPCookieEchoChunk *dup() const {return new SCTPCookieEchoChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setCookieArraySize(unsigned int size);
    virtual unsigned int getCookieArraySize() const;
    virtual char getCookie(unsigned int k) const;
    virtual void setCookie(unsigned int k, char cookie);
    virtual cPacketPtr& getStateCookie();
    virtual const cPacketPtr& getStateCookie() const {return const_cast<SCTPCookieEchoChunk*>(this)->getStateCookie();}
    virtual void setStateCookie(const cPacketPtr& stateCookie);
    virtual void setUnrecognizedParametersArraySize(unsigned int size);
    virtual unsigned int getUnrecognizedParametersArraySize() const;
    virtual uint8 getUnrecognizedParameters(unsigned int k) const;
    virtual void setUnrecognizedParameters(unsigned int k, uint8 unrecognizedParameters);
};

inline void doPacking(cCommBuffer *b, SCTPCookieEchoChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPCookieEchoChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:116</tt> by nedtool.
 * <pre>
 * message SCTPCookie extends cPacket
 * {
 *     simtime_t creationTime;
 *     uint32 localTag;
 *     uint32 peerTag;
 *     uint8 localTieTag[];
 *     uint8 peerTieTag[];
 * }
 * </pre>
 */
class SCTPCookie : public ::cPacket
{
  protected:
    simtime_t creationTime_var;
    uint32 localTag_var;
    uint32 peerTag_var;
    uint8 *localTieTag_var; // array ptr
    unsigned int localTieTag_arraysize;
    uint8 *peerTieTag_var; // array ptr
    unsigned int peerTieTag_arraysize;

  private:
    void copy(const SCTPCookie& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPCookie&);

  public:
    SCTPCookie(const char *name=NULL, int kind=0);
    SCTPCookie(const SCTPCookie& other);
    virtual ~SCTPCookie();
    SCTPCookie& operator=(const SCTPCookie& other);
    virtual SCTPCookie *dup() const {return new SCTPCookie(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual simtime_t getCreationTime() const;
    virtual void setCreationTime(simtime_t creationTime);
    virtual uint32 getLocalTag() const;
    virtual void setLocalTag(uint32 localTag);
    virtual uint32 getPeerTag() const;
    virtual void setPeerTag(uint32 peerTag);
    virtual void setLocalTieTagArraySize(unsigned int size);
    virtual unsigned int getLocalTieTagArraySize() const;
    virtual uint8 getLocalTieTag(unsigned int k) const;
    virtual void setLocalTieTag(unsigned int k, uint8 localTieTag);
    virtual void setPeerTieTagArraySize(unsigned int size);
    virtual unsigned int getPeerTieTagArraySize() const;
    virtual uint8 getPeerTieTag(unsigned int k) const;
    virtual void setPeerTieTag(unsigned int k, uint8 peerTieTag);
};

inline void doPacking(cCommBuffer *b, SCTPCookie& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPCookie& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:125</tt> by nedtool.
 * <pre>
 * message SCTPCookieAckChunk extends SCTPChunk
 * {
 * }
 * </pre>
 */
class SCTPCookieAckChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:

  private:
    void copy(const SCTPCookieAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPCookieAckChunk&);

  public:
    SCTPCookieAckChunk(const char *name=NULL, int kind=0);
    SCTPCookieAckChunk(const SCTPCookieAckChunk& other);
    virtual ~SCTPCookieAckChunk();
    SCTPCookieAckChunk& operator=(const SCTPCookieAckChunk& other);
    virtual SCTPCookieAckChunk *dup() const {return new SCTPCookieAckChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SCTPCookieAckChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPCookieAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:129</tt> by nedtool.
 * <pre>
 * message SCTPDataMsg extends cPacket
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     simtime_t enqueuingTime;
 *     simtime_t expiryTime;
 *     uint32 ppid;
 *     L3Address initialDestination;
 *     uint32 msgNum;
 *     uint16 sid;
 *     bool ordered;
 *     uint32 booksize;
 *     uint32 rtx;
 *     bool fragment;
 *     uint32 prMethod;
 *     uint32 priority;
 *     bool strReset;
 *     bool sackNow;
 * }
 * </pre>
 */
class SCTPDataMsg : public ::cPacket
{
  protected:
    bool eBit_var;
    bool bBit_var;
    simtime_t enqueuingTime_var;
    simtime_t expiryTime_var;
    uint32 ppid_var;
    L3Address initialDestination_var;
    uint32 msgNum_var;
    uint16 sid_var;
    bool ordered_var;
    uint32 booksize_var;
    uint32 rtx_var;
    bool fragment_var;
    uint32 prMethod_var;
    uint32 priority_var;
    bool strReset_var;
    bool sackNow_var;

  private:
    void copy(const SCTPDataMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPDataMsg&);

  public:
    SCTPDataMsg(const char *name=NULL, int kind=0);
    SCTPDataMsg(const SCTPDataMsg& other);
    virtual ~SCTPDataMsg();
    SCTPDataMsg& operator=(const SCTPDataMsg& other);
    virtual SCTPDataMsg *dup() const {return new SCTPDataMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(simtime_t enqueuingTime);
    virtual simtime_t getExpiryTime() const;
    virtual void setExpiryTime(simtime_t expiryTime);
    virtual uint32 getPpid() const;
    virtual void setPpid(uint32 ppid);
    virtual L3Address& getInitialDestination();
    virtual const L3Address& getInitialDestination() const {return const_cast<SCTPDataMsg*>(this)->getInitialDestination();}
    virtual void setInitialDestination(const L3Address& initialDestination);
    virtual uint32 getMsgNum() const;
    virtual void setMsgNum(uint32 msgNum);
    virtual uint16 getSid() const;
    virtual void setSid(uint16 sid);
    virtual bool getOrdered() const;
    virtual void setOrdered(bool ordered);
    virtual uint32 getBooksize() const;
    virtual void setBooksize(uint32 booksize);
    virtual uint32 getRtx() const;
    virtual void setRtx(uint32 rtx);
    virtual bool getFragment() const;
    virtual void setFragment(bool fragment);
    virtual uint32 getPrMethod() const;
    virtual void setPrMethod(uint32 prMethod);
    virtual uint32 getPriority() const;
    virtual void setPriority(uint32 priority);
    virtual bool getStrReset() const;
    virtual void setStrReset(bool strReset);
    virtual bool getSackNow() const;
    virtual void setSackNow(bool sackNow);
};

inline void doPacking(cCommBuffer *b, SCTPDataMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPDataMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:150</tt> by nedtool.
 * <pre>
 * message SCTPDataChunk extends SCTPChunk
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     bool uBit = 0;
 *     bool iBit = 0;
 *     // Transmission Sequence Number
 *     uint32 tsn;
 *     // Stream identifier
 *     uint16 sid;
 *     // Stream Sequence Number
 *     uint16 ssn;
 *     // Payload Protocol Identifier
 *     uint32 ppid;
 *     simtime_t enqueuingTime;
 *     simtime_t firstSendTime;
 * }
 * </pre>
 */
class SCTPDataChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    bool eBit_var;
    bool bBit_var;
    bool uBit_var;
    bool iBit_var;
    uint32 tsn_var;
    uint16 sid_var;
    uint16 ssn_var;
    uint32 ppid_var;
    simtime_t enqueuingTime_var;
    simtime_t firstSendTime_var;

  private:
    void copy(const SCTPDataChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPDataChunk&);

  public:
    SCTPDataChunk(const char *name=NULL, int kind=0);
    SCTPDataChunk(const SCTPDataChunk& other);
    virtual ~SCTPDataChunk();
    SCTPDataChunk& operator=(const SCTPDataChunk& other);
    virtual SCTPDataChunk *dup() const {return new SCTPDataChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual bool getUBit() const;
    virtual void setUBit(bool uBit);
    virtual bool getIBit() const;
    virtual void setIBit(bool iBit);
    virtual uint32 getTsn() const;
    virtual void setTsn(uint32 tsn);
    virtual uint16 getSid() const;
    virtual void setSid(uint16 sid);
    virtual uint16 getSsn() const;
    virtual void setSsn(uint16 ssn);
    virtual uint32 getPpid() const;
    virtual void setPpid(uint32 ppid);
    virtual simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(simtime_t enqueuingTime);
    virtual simtime_t getFirstSendTime() const;
    virtual void setFirstSendTime(simtime_t firstSendTime);
};

inline void doPacking(cCommBuffer *b, SCTPDataChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPDataChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:169</tt> by nedtool.
 * <pre>
 * message SCTPForwardTsnChunk extends SCTPChunk
 * {
 *     uint32 newCumTsn;
 *     uint16 sid[];
 *     short ssn[]; // set -1 in case of unordered delivery
 * }
 * </pre>
 */
class SCTPForwardTsnChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 newCumTsn_var;
    uint16 *sid_var; // array ptr
    unsigned int sid_arraysize;
    short *ssn_var; // array ptr
    unsigned int ssn_arraysize;

  private:
    void copy(const SCTPForwardTsnChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPForwardTsnChunk&);

  public:
    SCTPForwardTsnChunk(const char *name=NULL, int kind=0);
    SCTPForwardTsnChunk(const SCTPForwardTsnChunk& other);
    virtual ~SCTPForwardTsnChunk();
    SCTPForwardTsnChunk& operator=(const SCTPForwardTsnChunk& other);
    virtual SCTPForwardTsnChunk *dup() const {return new SCTPForwardTsnChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getNewCumTsn() const;
    virtual void setNewCumTsn(uint32 newCumTsn);
    virtual void setSidArraySize(unsigned int size);
    virtual unsigned int getSidArraySize() const;
    virtual uint16 getSid(unsigned int k) const;
    virtual void setSid(unsigned int k, uint16 sid);
    virtual void setSsnArraySize(unsigned int size);
    virtual unsigned int getSsnArraySize() const;
    virtual short getSsn(unsigned int k) const;
    virtual void setSsn(unsigned int k, short ssn);
};

inline void doPacking(cCommBuffer *b, SCTPForwardTsnChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPForwardTsnChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:176</tt> by nedtool.
 * <pre>
 * message SCTPSackChunk extends SCTPChunk
 * {
 *     // Cumulative TSN Ack
 *     uint32 cumTsnAck;
 *     // Advertised Receiver Window Credit
 *     uint32 a_rwnd;
 *     // Number of Gap Ack Blocks
 *     uint16 numGaps;
 *     // Number of Non-Revokable Gap Ack Blocks
 *     uint16 numNrGaps;
 *     // Number of Duplicate TSNs
 *     uint16 numDupTsns;
 *     // Start and End of Gap Ack Blocks
 *     bool isNrSack;
 *     uint32 gapStart[];
 *     uint32 gapStop[];
 *     uint32 dupTsns[];
 *     uint32 sackSeqNum = 0;
 *     uint32 nrGapStart[];
 *     uint32 nrGapStop[];
 *     uint32 msg_rwnd;
 *     uint8 dacPacketsRcvd = 0;
 *     bool nrSubtractRGaps = false;
 * }
 * </pre>
 */
class SCTPSackChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 cumTsnAck_var;
    uint32 a_rwnd_var;
    uint16 numGaps_var;
    uint16 numNrGaps_var;
    uint16 numDupTsns_var;
    bool isNrSack_var;
    uint32 *gapStart_var; // array ptr
    unsigned int gapStart_arraysize;
    uint32 *gapStop_var; // array ptr
    unsigned int gapStop_arraysize;
    uint32 *dupTsns_var; // array ptr
    unsigned int dupTsns_arraysize;
    uint32 sackSeqNum_var;
    uint32 *nrGapStart_var; // array ptr
    unsigned int nrGapStart_arraysize;
    uint32 *nrGapStop_var; // array ptr
    unsigned int nrGapStop_arraysize;
    uint32 msg_rwnd_var;
    uint8 dacPacketsRcvd_var;
    bool nrSubtractRGaps_var;

  private:
    void copy(const SCTPSackChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSackChunk&);

  public:
    SCTPSackChunk(const char *name=NULL, int kind=0);
    SCTPSackChunk(const SCTPSackChunk& other);
    virtual ~SCTPSackChunk();
    SCTPSackChunk& operator=(const SCTPSackChunk& other);
    virtual SCTPSackChunk *dup() const {return new SCTPSackChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getCumTsnAck() const;
    virtual void setCumTsnAck(uint32 cumTsnAck);
    virtual uint32 getA_rwnd() const;
    virtual void setA_rwnd(uint32 a_rwnd);
    virtual uint16 getNumGaps() const;
    virtual void setNumGaps(uint16 numGaps);
    virtual uint16 getNumNrGaps() const;
    virtual void setNumNrGaps(uint16 numNrGaps);
    virtual uint16 getNumDupTsns() const;
    virtual void setNumDupTsns(uint16 numDupTsns);
    virtual bool getIsNrSack() const;
    virtual void setIsNrSack(bool isNrSack);
    virtual void setGapStartArraySize(unsigned int size);
    virtual unsigned int getGapStartArraySize() const;
    virtual uint32 getGapStart(unsigned int k) const;
    virtual void setGapStart(unsigned int k, uint32 gapStart);
    virtual void setGapStopArraySize(unsigned int size);
    virtual unsigned int getGapStopArraySize() const;
    virtual uint32 getGapStop(unsigned int k) const;
    virtual void setGapStop(unsigned int k, uint32 gapStop);
    virtual void setDupTsnsArraySize(unsigned int size);
    virtual unsigned int getDupTsnsArraySize() const;
    virtual uint32 getDupTsns(unsigned int k) const;
    virtual void setDupTsns(unsigned int k, uint32 dupTsns);
    virtual uint32 getSackSeqNum() const;
    virtual void setSackSeqNum(uint32 sackSeqNum);
    virtual void setNrGapStartArraySize(unsigned int size);
    virtual unsigned int getNrGapStartArraySize() const;
    virtual uint32 getNrGapStart(unsigned int k) const;
    virtual void setNrGapStart(unsigned int k, uint32 nrGapStart);
    virtual void setNrGapStopArraySize(unsigned int size);
    virtual unsigned int getNrGapStopArraySize() const;
    virtual uint32 getNrGapStop(unsigned int k) const;
    virtual void setNrGapStop(unsigned int k, uint32 nrGapStop);
    virtual uint32 getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32 msg_rwnd);
    virtual uint8 getDacPacketsRcvd() const;
    virtual void setDacPacketsRcvd(uint8 dacPacketsRcvd);
    virtual bool getNrSubtractRGaps() const;
    virtual void setNrSubtractRGaps(bool nrSubtractRGaps);
};

inline void doPacking(cCommBuffer *b, SCTPSackChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPSackChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:201</tt> by nedtool.
 * <pre>
 * message SCTPAbortChunk extends SCTPChunk
 * {
 *     // Chunk Flags
 *     bool T_Bit = 0;
 * }
 * </pre>
 */
class SCTPAbortChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    bool T_Bit_var;

  private:
    void copy(const SCTPAbortChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAbortChunk&);

  public:
    SCTPAbortChunk(const char *name=NULL, int kind=0);
    SCTPAbortChunk(const SCTPAbortChunk& other);
    virtual ~SCTPAbortChunk();
    SCTPAbortChunk& operator=(const SCTPAbortChunk& other);
    virtual SCTPAbortChunk *dup() const {return new SCTPAbortChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getT_Bit() const;
    virtual void setT_Bit(bool T_Bit);
};

inline void doPacking(cCommBuffer *b, SCTPAbortChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPAbortChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:207</tt> by nedtool.
 * <pre>
 * message SCTPHeartbeatChunk extends SCTPChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class SCTPHeartbeatChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    L3Address remoteAddr_var;
    simtime_t timeField_var;
    char *info_var; // array ptr
    unsigned int info_arraysize;

  private:
    void copy(const SCTPHeartbeatChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPHeartbeatChunk&);

  public:
    SCTPHeartbeatChunk(const char *name=NULL, int kind=0);
    SCTPHeartbeatChunk(const SCTPHeartbeatChunk& other);
    virtual ~SCTPHeartbeatChunk();
    SCTPHeartbeatChunk& operator=(const SCTPHeartbeatChunk& other);
    virtual SCTPHeartbeatChunk *dup() const {return new SCTPHeartbeatChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<SCTPHeartbeatChunk*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual simtime_t getTimeField() const;
    virtual void setTimeField(simtime_t timeField);
    virtual void setInfoArraySize(unsigned int size);
    virtual unsigned int getInfoArraySize() const;
    virtual char getInfo(unsigned int k) const;
    virtual void setInfo(unsigned int k, char info);
};

inline void doPacking(cCommBuffer *b, SCTPHeartbeatChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPHeartbeatChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:214</tt> by nedtool.
 * <pre>
 * message SCTPHeartbeatAckChunk extends SCTPChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class SCTPHeartbeatAckChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    L3Address remoteAddr_var;
    simtime_t timeField_var;
    char *info_var; // array ptr
    unsigned int info_arraysize;

  private:
    void copy(const SCTPHeartbeatAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPHeartbeatAckChunk&);

  public:
    SCTPHeartbeatAckChunk(const char *name=NULL, int kind=0);
    SCTPHeartbeatAckChunk(const SCTPHeartbeatAckChunk& other);
    virtual ~SCTPHeartbeatAckChunk();
    SCTPHeartbeatAckChunk& operator=(const SCTPHeartbeatAckChunk& other);
    virtual SCTPHeartbeatAckChunk *dup() const {return new SCTPHeartbeatAckChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<SCTPHeartbeatAckChunk*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual simtime_t getTimeField() const;
    virtual void setTimeField(simtime_t timeField);
    virtual void setInfoArraySize(unsigned int size);
    virtual unsigned int getInfoArraySize() const;
    virtual char getInfo(unsigned int k) const;
    virtual void setInfo(unsigned int k, char info);
};

inline void doPacking(cCommBuffer *b, SCTPHeartbeatAckChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPHeartbeatAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:221</tt> by nedtool.
 * <pre>
 * message SCTPShutdownChunk extends SCTPChunk
 * {
 *     uint32 cumTsnAck;
 * }
 * </pre>
 */
class SCTPShutdownChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 cumTsnAck_var;

  private:
    void copy(const SCTPShutdownChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPShutdownChunk&);

  public:
    SCTPShutdownChunk(const char *name=NULL, int kind=0);
    SCTPShutdownChunk(const SCTPShutdownChunk& other);
    virtual ~SCTPShutdownChunk();
    SCTPShutdownChunk& operator=(const SCTPShutdownChunk& other);
    virtual SCTPShutdownChunk *dup() const {return new SCTPShutdownChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getCumTsnAck() const;
    virtual void setCumTsnAck(uint32 cumTsnAck);
};

inline void doPacking(cCommBuffer *b, SCTPShutdownChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPShutdownChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:226</tt> by nedtool.
 * <pre>
 * message SCTPShutdownAckChunk extends SCTPChunk
 * {
 * }
 * </pre>
 */
class SCTPShutdownAckChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:

  private:
    void copy(const SCTPShutdownAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPShutdownAckChunk&);

  public:
    SCTPShutdownAckChunk(const char *name=NULL, int kind=0);
    SCTPShutdownAckChunk(const SCTPShutdownAckChunk& other);
    virtual ~SCTPShutdownAckChunk();
    SCTPShutdownAckChunk& operator=(const SCTPShutdownAckChunk& other);
    virtual SCTPShutdownAckChunk *dup() const {return new SCTPShutdownAckChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SCTPShutdownAckChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPShutdownAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:230</tt> by nedtool.
 * <pre>
 * message SCTPShutdownCompleteChunk extends SCTPChunk
 * {
 *     bool TBit = 0;
 * }
 * </pre>
 */
class SCTPShutdownCompleteChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    bool TBit_var;

  private:
    void copy(const SCTPShutdownCompleteChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPShutdownCompleteChunk&);

  public:
    SCTPShutdownCompleteChunk(const char *name=NULL, int kind=0);
    SCTPShutdownCompleteChunk(const SCTPShutdownCompleteChunk& other);
    virtual ~SCTPShutdownCompleteChunk();
    SCTPShutdownCompleteChunk& operator=(const SCTPShutdownCompleteChunk& other);
    virtual SCTPShutdownCompleteChunk *dup() const {return new SCTPShutdownCompleteChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
};

inline void doPacking(cCommBuffer *b, SCTPShutdownCompleteChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPShutdownCompleteChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:235</tt> by nedtool.
 * <pre>
 * message SCTPErrorChunk extends SCTPChunk
 * {
 *     @customize(true);
 *     bool TBit = 0;
 *     bool MBit = 0;
 *     abstract cPacketPtr parameters[];
 * }
 * </pre>
 *
 * SCTPErrorChunk_Base is only useful if it gets subclassed, and SCTPErrorChunk is derived from it.
 * The minimum code to be written for SCTPErrorChunk is the following:
 *
 * <pre>
 * class SCTPErrorChunk : public SCTPErrorChunk_Base
 * {
 *   private:
 *     void copy(const SCTPErrorChunk& other) { ... }

 *   public:
 *     SCTPErrorChunk(const char *name=NULL, int kind=0) : SCTPErrorChunk_Base(name,kind) {}
 *     SCTPErrorChunk(const SCTPErrorChunk& other) : SCTPErrorChunk_Base(other) {copy(other);}
 *     SCTPErrorChunk& operator=(const SCTPErrorChunk& other) {if (this==&other) return *this; SCTPErrorChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPErrorChunk *dup() const {return new SCTPErrorChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPErrorChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPErrorChunk);
 * </pre>
 */
class SCTPErrorChunk_Base : public ::inetveins::sctp::SCTPChunk
{
  protected:
    bool TBit_var;
    bool MBit_var;

  private:
    void copy(const SCTPErrorChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPErrorChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPErrorChunk_Base(const char *name=NULL, int kind=0);
    SCTPErrorChunk_Base(const SCTPErrorChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPErrorChunk_Base& operator=(const SCTPErrorChunk_Base& other);

  public:
    virtual ~SCTPErrorChunk_Base();
    virtual SCTPErrorChunk_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class SCTPErrorChunk");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
    virtual bool getMBit() const;
    virtual void setMBit(bool MBit);
    virtual void setParametersArraySize(unsigned int size) = 0;
    virtual unsigned int getParametersArraySize() const = 0;
    virtual cPacketPtr& getParameters(unsigned int k) = 0;
    virtual const cPacketPtr& getParameters(unsigned int k) const {return const_cast<SCTPErrorChunk_Base*>(this)->getParameters(k);}
    virtual void setParameters(unsigned int k, const cPacketPtr& parameters) = 0;
};

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:243</tt> by nedtool.
 * <pre>
 * message SCTPParameter extends cPacket
 * {
 *     uint16 parameterType;
 * }
 * </pre>
 */
class SCTPParameter : public ::cPacket
{
  protected:
    uint16 parameterType_var;

  private:
    void copy(const SCTPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPParameter&);

  public:
    SCTPParameter(const char *name=NULL, int kind=0);
    SCTPParameter(const SCTPParameter& other);
    virtual ~SCTPParameter();
    SCTPParameter& operator=(const SCTPParameter& other);
    virtual SCTPParameter *dup() const {return new SCTPParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16 getParameterType() const;
    virtual void setParameterType(uint16 parameterType);
};

inline void doPacking(cCommBuffer *b, SCTPParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:248</tt> by nedtool.
 * <pre>
 * message SCTPPacketDropChunk extends SCTPChunk
 * {
 *     bool cFlag;
 *     bool tFlag;
 *     bool bFlag;
 *     bool mFlag;
 *     uint32 maxRwnd;
 *     uint32 queuedData;
 *     uint16 truncLength;
 * }
 * </pre>
 */
class SCTPPacketDropChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    bool cFlag_var;
    bool tFlag_var;
    bool bFlag_var;
    bool mFlag_var;
    uint32 maxRwnd_var;
    uint32 queuedData_var;
    uint16 truncLength_var;

  private:
    void copy(const SCTPPacketDropChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPPacketDropChunk&);

  public:
    SCTPPacketDropChunk(const char *name=NULL, int kind=0);
    SCTPPacketDropChunk(const SCTPPacketDropChunk& other);
    virtual ~SCTPPacketDropChunk();
    SCTPPacketDropChunk& operator=(const SCTPPacketDropChunk& other);
    virtual SCTPPacketDropChunk *dup() const {return new SCTPPacketDropChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getCFlag() const;
    virtual void setCFlag(bool cFlag);
    virtual bool getTFlag() const;
    virtual void setTFlag(bool tFlag);
    virtual bool getBFlag() const;
    virtual void setBFlag(bool bFlag);
    virtual bool getMFlag() const;
    virtual void setMFlag(bool mFlag);
    virtual uint32 getMaxRwnd() const;
    virtual void setMaxRwnd(uint32 maxRwnd);
    virtual uint32 getQueuedData() const;
    virtual void setQueuedData(uint32 queuedData);
    virtual uint16 getTruncLength() const;
    virtual void setTruncLength(uint16 truncLength);
};

inline void doPacking(cCommBuffer *b, SCTPPacketDropChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPPacketDropChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:259</tt> by nedtool.
 * <pre>
 * message SCTPStreamResetChunk extends SCTPChunk
 * {
 *     @customize(true);
 *     abstract cPacketPtr parameters[];
 * }
 * </pre>
 *
 * SCTPStreamResetChunk_Base is only useful if it gets subclassed, and SCTPStreamResetChunk is derived from it.
 * The minimum code to be written for SCTPStreamResetChunk is the following:
 *
 * <pre>
 * class SCTPStreamResetChunk : public SCTPStreamResetChunk_Base
 * {
 *   private:
 *     void copy(const SCTPStreamResetChunk& other) { ... }

 *   public:
 *     SCTPStreamResetChunk(const char *name=NULL, int kind=0) : SCTPStreamResetChunk_Base(name,kind) {}
 *     SCTPStreamResetChunk(const SCTPStreamResetChunk& other) : SCTPStreamResetChunk_Base(other) {copy(other);}
 *     SCTPStreamResetChunk& operator=(const SCTPStreamResetChunk& other) {if (this==&other) return *this; SCTPStreamResetChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPStreamResetChunk *dup() const {return new SCTPStreamResetChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPStreamResetChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPStreamResetChunk);
 * </pre>
 */
class SCTPStreamResetChunk_Base : public ::inetveins::sctp::SCTPChunk
{
  protected:

  private:
    void copy(const SCTPStreamResetChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPStreamResetChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPStreamResetChunk_Base(const char *name=NULL, int kind=0);
    SCTPStreamResetChunk_Base(const SCTPStreamResetChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPStreamResetChunk_Base& operator=(const SCTPStreamResetChunk_Base& other);

  public:
    virtual ~SCTPStreamResetChunk_Base();
    virtual SCTPStreamResetChunk_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class SCTPStreamResetChunk");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setParametersArraySize(unsigned int size) = 0;
    virtual unsigned int getParametersArraySize() const = 0;
    virtual cPacketPtr& getParameters(unsigned int k) = 0;
    virtual const cPacketPtr& getParameters(unsigned int k) const {return const_cast<SCTPStreamResetChunk_Base*>(this)->getParameters(k);}
    virtual void setParameters(unsigned int k, const cPacketPtr& parameters) = 0;
};

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:265</tt> by nedtool.
 * <pre>
 * message SCTPOutgoingSSNResetRequestParameter extends SCTPParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number: initialized with the initial TSN, then incremented
 *     uint32 srResSn; //Stream Reset Response Sequence Number
 *     uint32 lastTsn; //Senders last assigned TSN
 *     uint16 streamNumbers[];
 * }
 * </pre>
 */
class SCTPOutgoingSSNResetRequestParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 srReqSn_var;
    uint32 srResSn_var;
    uint32 lastTsn_var;
    uint16 *streamNumbers_var; // array ptr
    unsigned int streamNumbers_arraysize;

  private:
    void copy(const SCTPOutgoingSSNResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPOutgoingSSNResetRequestParameter&);

  public:
    SCTPOutgoingSSNResetRequestParameter(const char *name=NULL, int kind=0);
    SCTPOutgoingSSNResetRequestParameter(const SCTPOutgoingSSNResetRequestParameter& other);
    virtual ~SCTPOutgoingSSNResetRequestParameter();
    SCTPOutgoingSSNResetRequestParameter& operator=(const SCTPOutgoingSSNResetRequestParameter& other);
    virtual SCTPOutgoingSSNResetRequestParameter *dup() const {return new SCTPOutgoingSSNResetRequestParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getSrReqSn() const;
    virtual void setSrReqSn(uint32 srReqSn);
    virtual uint32 getSrResSn() const;
    virtual void setSrResSn(uint32 srResSn);
    virtual uint32 getLastTsn() const;
    virtual void setLastTsn(uint32 lastTsn);
    virtual void setStreamNumbersArraySize(unsigned int size);
    virtual unsigned int getStreamNumbersArraySize() const;
    virtual uint16 getStreamNumbers(unsigned int k) const;
    virtual void setStreamNumbers(unsigned int k, uint16 streamNumbers);
};

inline void doPacking(cCommBuffer *b, SCTPOutgoingSSNResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPOutgoingSSNResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:273</tt> by nedtool.
 * <pre>
 * message SCTPIncomingSSNResetRequestParameter extends SCTPParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 *     uint16 streamNumbers[];
 * }
 * </pre>
 */
class SCTPIncomingSSNResetRequestParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 srReqSn_var;
    uint16 *streamNumbers_var; // array ptr
    unsigned int streamNumbers_arraysize;

  private:
    void copy(const SCTPIncomingSSNResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPIncomingSSNResetRequestParameter&);

  public:
    SCTPIncomingSSNResetRequestParameter(const char *name=NULL, int kind=0);
    SCTPIncomingSSNResetRequestParameter(const SCTPIncomingSSNResetRequestParameter& other);
    virtual ~SCTPIncomingSSNResetRequestParameter();
    SCTPIncomingSSNResetRequestParameter& operator=(const SCTPIncomingSSNResetRequestParameter& other);
    virtual SCTPIncomingSSNResetRequestParameter *dup() const {return new SCTPIncomingSSNResetRequestParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getSrReqSn() const;
    virtual void setSrReqSn(uint32 srReqSn);
    virtual void setStreamNumbersArraySize(unsigned int size);
    virtual unsigned int getStreamNumbersArraySize() const;
    virtual uint16 getStreamNumbers(unsigned int k) const;
    virtual void setStreamNumbers(unsigned int k, uint16 streamNumbers);
};

inline void doPacking(cCommBuffer *b, SCTPIncomingSSNResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPIncomingSSNResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:279</tt> by nedtool.
 * <pre>
 * message SCTPSSNTSNResetRequestParameter extends SCTPParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 * }
 * </pre>
 */
class SCTPSSNTSNResetRequestParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 srReqSn_var;

  private:
    void copy(const SCTPSSNTSNResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSSNTSNResetRequestParameter&);

  public:
    SCTPSSNTSNResetRequestParameter(const char *name=NULL, int kind=0);
    SCTPSSNTSNResetRequestParameter(const SCTPSSNTSNResetRequestParameter& other);
    virtual ~SCTPSSNTSNResetRequestParameter();
    SCTPSSNTSNResetRequestParameter& operator=(const SCTPSSNTSNResetRequestParameter& other);
    virtual SCTPSSNTSNResetRequestParameter *dup() const {return new SCTPSSNTSNResetRequestParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getSrReqSn() const;
    virtual void setSrReqSn(uint32 srReqSn);
};

inline void doPacking(cCommBuffer *b, SCTPSSNTSNResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPSSNTSNResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:284</tt> by nedtool.
 * <pre>
 * message SCTPStreamResetResponseParameter extends SCTPParameter
 * {
 *     uint32 srResSn; //Stream Reset Response Sequence Number
 *     uint32 result;
 *     uint32 sendersNextTsn = 0;
 *     uint32 receiversNextTsn = 0;
 * }
 * </pre>
 */
class SCTPStreamResetResponseParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 srResSn_var;
    uint32 result_var;
    uint32 sendersNextTsn_var;
    uint32 receiversNextTsn_var;

  private:
    void copy(const SCTPStreamResetResponseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPStreamResetResponseParameter&);

  public:
    SCTPStreamResetResponseParameter(const char *name=NULL, int kind=0);
    SCTPStreamResetResponseParameter(const SCTPStreamResetResponseParameter& other);
    virtual ~SCTPStreamResetResponseParameter();
    SCTPStreamResetResponseParameter& operator=(const SCTPStreamResetResponseParameter& other);
    virtual SCTPStreamResetResponseParameter *dup() const {return new SCTPStreamResetResponseParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getSrResSn() const;
    virtual void setSrResSn(uint32 srResSn);
    virtual uint32 getResult() const;
    virtual void setResult(uint32 result);
    virtual uint32 getSendersNextTsn() const;
    virtual void setSendersNextTsn(uint32 sendersNextTsn);
    virtual uint32 getReceiversNextTsn() const;
    virtual void setReceiversNextTsn(uint32 receiversNextTsn);
};

inline void doPacking(cCommBuffer *b, SCTPStreamResetResponseParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPStreamResetResponseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:292</tt> by nedtool.
 * <pre>
 * message SCTPResetTimer extends cPacket
 * {
 *     uint32 inSN; //Stream Reset Response Sequence Number for Incoming Reset Request
 *     bool inAcked;   // false, when timer is running for the Reset Response Sequence Number, true otherwise
 *     uint32 outSN; //Stream Reset Response Sequence Number for Outgoing Reset Request
 *     bool outAcked;
 * }
 * </pre>
 */
class SCTPResetTimer : public ::cPacket
{
  protected:
    uint32 inSN_var;
    bool inAcked_var;
    uint32 outSN_var;
    bool outAcked_var;

  private:
    void copy(const SCTPResetTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPResetTimer&);

  public:
    SCTPResetTimer(const char *name=NULL, int kind=0);
    SCTPResetTimer(const SCTPResetTimer& other);
    virtual ~SCTPResetTimer();
    SCTPResetTimer& operator=(const SCTPResetTimer& other);
    virtual SCTPResetTimer *dup() const {return new SCTPResetTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getInSN() const;
    virtual void setInSN(uint32 inSN);
    virtual bool getInAcked() const;
    virtual void setInAcked(bool inAcked);
    virtual uint32 getOutSN() const;
    virtual void setOutSN(uint32 outSN);
    virtual bool getOutAcked() const;
    virtual void setOutAcked(bool outAcked);
};

inline void doPacking(cCommBuffer *b, SCTPResetTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPResetTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:300</tt> by nedtool.
 * <pre>
 * message SCTPAuthenticationChunk extends SCTPChunk
 * {
 *     uint16 sharedKey;
 *     uint16 hMacIdentifier;
 *     bool hMacOk;
 *     uint32 HMAC[];
 * }
 * </pre>
 */
class SCTPAuthenticationChunk : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint16 sharedKey_var;
    uint16 hMacIdentifier_var;
    bool hMacOk_var;
    uint32 *HMAC_var; // array ptr
    unsigned int HMAC_arraysize;

  private:
    void copy(const SCTPAuthenticationChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAuthenticationChunk&);

  public:
    SCTPAuthenticationChunk(const char *name=NULL, int kind=0);
    SCTPAuthenticationChunk(const SCTPAuthenticationChunk& other);
    virtual ~SCTPAuthenticationChunk();
    SCTPAuthenticationChunk& operator=(const SCTPAuthenticationChunk& other);
    virtual SCTPAuthenticationChunk *dup() const {return new SCTPAuthenticationChunk(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16 getSharedKey() const;
    virtual void setSharedKey(uint16 sharedKey);
    virtual uint16 getHMacIdentifier() const;
    virtual void setHMacIdentifier(uint16 hMacIdentifier);
    virtual bool getHMacOk() const;
    virtual void setHMacOk(bool hMacOk);
    virtual void setHMACArraySize(unsigned int size);
    virtual unsigned int getHMACArraySize() const;
    virtual uint32 getHMAC(unsigned int k) const;
    virtual void setHMAC(unsigned int k, uint32 HMAC);
};

inline void doPacking(cCommBuffer *b, SCTPAuthenticationChunk& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPAuthenticationChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:308</tt> by nedtool.
 * <pre>
 * message SCTPAsconfChunk extends SCTPChunk
 * {
 *     @customize(true);
 *     uint32 serialNumber;
 *     L3Address addressParam;
 *     uint32 peerVTag; //for NAT
 *     abstract cPacketPtr asconfParams[];
 * }
 * </pre>
 *
 * SCTPAsconfChunk_Base is only useful if it gets subclassed, and SCTPAsconfChunk is derived from it.
 * The minimum code to be written for SCTPAsconfChunk is the following:
 *
 * <pre>
 * class SCTPAsconfChunk : public SCTPAsconfChunk_Base
 * {
 *   private:
 *     void copy(const SCTPAsconfChunk& other) { ... }

 *   public:
 *     SCTPAsconfChunk(const char *name=NULL, int kind=0) : SCTPAsconfChunk_Base(name,kind) {}
 *     SCTPAsconfChunk(const SCTPAsconfChunk& other) : SCTPAsconfChunk_Base(other) {copy(other);}
 *     SCTPAsconfChunk& operator=(const SCTPAsconfChunk& other) {if (this==&other) return *this; SCTPAsconfChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPAsconfChunk *dup() const {return new SCTPAsconfChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPAsconfChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPAsconfChunk);
 * </pre>
 */
class SCTPAsconfChunk_Base : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 serialNumber_var;
    L3Address addressParam_var;
    uint32 peerVTag_var;

  private:
    void copy(const SCTPAsconfChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAsconfChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPAsconfChunk_Base(const char *name=NULL, int kind=0);
    SCTPAsconfChunk_Base(const SCTPAsconfChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPAsconfChunk_Base& operator=(const SCTPAsconfChunk_Base& other);

  public:
    virtual ~SCTPAsconfChunk_Base();
    virtual SCTPAsconfChunk_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class SCTPAsconfChunk");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getSerialNumber() const;
    virtual void setSerialNumber(uint32 serialNumber);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPAsconfChunk_Base*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
    virtual uint32 getPeerVTag() const;
    virtual void setPeerVTag(uint32 peerVTag);
    virtual void setAsconfParamsArraySize(unsigned int size) = 0;
    virtual unsigned int getAsconfParamsArraySize() const = 0;
    virtual cPacketPtr& getAsconfParams(unsigned int k) = 0;
    virtual const cPacketPtr& getAsconfParams(unsigned int k) const {return const_cast<SCTPAsconfChunk_Base*>(this)->getAsconfParams(k);}
    virtual void setAsconfParams(unsigned int k, const cPacketPtr& asconfParams) = 0;
};

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:317</tt> by nedtool.
 * <pre>
 * message SCTPAsconfAckChunk extends SCTPChunk
 * {
 *     @customize(true);
 *     uint32 serialNumber;
 *     abstract cPacketPtr asconfResponse[];
 * }
 * </pre>
 *
 * SCTPAsconfAckChunk_Base is only useful if it gets subclassed, and SCTPAsconfAckChunk is derived from it.
 * The minimum code to be written for SCTPAsconfAckChunk is the following:
 *
 * <pre>
 * class SCTPAsconfAckChunk : public SCTPAsconfAckChunk_Base
 * {
 *   private:
 *     void copy(const SCTPAsconfAckChunk& other) { ... }

 *   public:
 *     SCTPAsconfAckChunk(const char *name=NULL, int kind=0) : SCTPAsconfAckChunk_Base(name,kind) {}
 *     SCTPAsconfAckChunk(const SCTPAsconfAckChunk& other) : SCTPAsconfAckChunk_Base(other) {copy(other);}
 *     SCTPAsconfAckChunk& operator=(const SCTPAsconfAckChunk& other) {if (this==&other) return *this; SCTPAsconfAckChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPAsconfAckChunk *dup() const {return new SCTPAsconfAckChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPAsconfAckChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPAsconfAckChunk);
 * </pre>
 */
class SCTPAsconfAckChunk_Base : public ::inetveins::sctp::SCTPChunk
{
  protected:
    uint32 serialNumber_var;

  private:
    void copy(const SCTPAsconfAckChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAsconfAckChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPAsconfAckChunk_Base(const char *name=NULL, int kind=0);
    SCTPAsconfAckChunk_Base(const SCTPAsconfAckChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPAsconfAckChunk_Base& operator=(const SCTPAsconfAckChunk_Base& other);

  public:
    virtual ~SCTPAsconfAckChunk_Base();
    virtual SCTPAsconfAckChunk_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class SCTPAsconfAckChunk");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getSerialNumber() const;
    virtual void setSerialNumber(uint32 serialNumber);
    virtual void setAsconfResponseArraySize(unsigned int size) = 0;
    virtual unsigned int getAsconfResponseArraySize() const = 0;
    virtual cPacketPtr& getAsconfResponse(unsigned int k) = 0;
    virtual const cPacketPtr& getAsconfResponse(unsigned int k) const {return const_cast<SCTPAsconfAckChunk_Base*>(this)->getAsconfResponse(k);}
    virtual void setAsconfResponse(unsigned int k, const cPacketPtr& asconfResponse) = 0;
};

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:324</tt> by nedtool.
 * <pre>
 * message SCTPAddIPParameter extends SCTPParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class SCTPAddIPParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 requestCorrelationId_var;
    L3Address addressParam_var;

  private:
    void copy(const SCTPAddIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAddIPParameter&);

  public:
    SCTPAddIPParameter(const char *name=NULL, int kind=0);
    SCTPAddIPParameter(const SCTPAddIPParameter& other);
    virtual ~SCTPAddIPParameter();
    SCTPAddIPParameter& operator=(const SCTPAddIPParameter& other);
    virtual SCTPAddIPParameter *dup() const {return new SCTPAddIPParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32 requestCorrelationId);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPAddIPParameter*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doPacking(cCommBuffer *b, SCTPAddIPParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPAddIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:330</tt> by nedtool.
 * <pre>
 * message SCTPDeleteIPParameter extends SCTPParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class SCTPDeleteIPParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 requestCorrelationId_var;
    L3Address addressParam_var;

  private:
    void copy(const SCTPDeleteIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPDeleteIPParameter&);

  public:
    SCTPDeleteIPParameter(const char *name=NULL, int kind=0);
    SCTPDeleteIPParameter(const SCTPDeleteIPParameter& other);
    virtual ~SCTPDeleteIPParameter();
    SCTPDeleteIPParameter& operator=(const SCTPDeleteIPParameter& other);
    virtual SCTPDeleteIPParameter *dup() const {return new SCTPDeleteIPParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32 requestCorrelationId);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPDeleteIPParameter*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doPacking(cCommBuffer *b, SCTPDeleteIPParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPDeleteIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:336</tt> by nedtool.
 * <pre>
 * message SCTPSetPrimaryIPParameter extends SCTPParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class SCTPSetPrimaryIPParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 requestCorrelationId_var;
    L3Address addressParam_var;

  private:
    void copy(const SCTPSetPrimaryIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSetPrimaryIPParameter&);

  public:
    SCTPSetPrimaryIPParameter(const char *name=NULL, int kind=0);
    SCTPSetPrimaryIPParameter(const SCTPSetPrimaryIPParameter& other);
    virtual ~SCTPSetPrimaryIPParameter();
    SCTPSetPrimaryIPParameter& operator=(const SCTPSetPrimaryIPParameter& other);
    virtual SCTPSetPrimaryIPParameter *dup() const {return new SCTPSetPrimaryIPParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32 requestCorrelationId);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPSetPrimaryIPParameter*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doPacking(cCommBuffer *b, SCTPSetPrimaryIPParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPSetPrimaryIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:342</tt> by nedtool.
 * <pre>
 * message SCTPSupportedExtensionsParameter extends SCTPParameter
 * {
 *     uint16 chunkTypes[];
 * }
 * </pre>
 */
class SCTPSupportedExtensionsParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint16 *chunkTypes_var; // array ptr
    unsigned int chunkTypes_arraysize;

  private:
    void copy(const SCTPSupportedExtensionsParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSupportedExtensionsParameter&);

  public:
    SCTPSupportedExtensionsParameter(const char *name=NULL, int kind=0);
    SCTPSupportedExtensionsParameter(const SCTPSupportedExtensionsParameter& other);
    virtual ~SCTPSupportedExtensionsParameter();
    SCTPSupportedExtensionsParameter& operator=(const SCTPSupportedExtensionsParameter& other);
    virtual SCTPSupportedExtensionsParameter *dup() const {return new SCTPSupportedExtensionsParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setChunkTypesArraySize(unsigned int size);
    virtual unsigned int getChunkTypesArraySize() const;
    virtual uint16 getChunkTypes(unsigned int k) const;
    virtual void setChunkTypes(unsigned int k, uint16 chunkTypes);
};

inline void doPacking(cCommBuffer *b, SCTPSupportedExtensionsParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPSupportedExtensionsParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:347</tt> by nedtool.
 * <pre>
 * message SCTPErrorCauseParameter extends SCTPParameter
 * {
 *     uint32 responseCorrelationId;
 *     uint32 errorCauseType;
 * }
 * </pre>
 */
class SCTPErrorCauseParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 responseCorrelationId_var;
    uint32 errorCauseType_var;

  private:
    void copy(const SCTPErrorCauseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPErrorCauseParameter&);

  public:
    SCTPErrorCauseParameter(const char *name=NULL, int kind=0);
    SCTPErrorCauseParameter(const SCTPErrorCauseParameter& other);
    virtual ~SCTPErrorCauseParameter();
    SCTPErrorCauseParameter& operator=(const SCTPErrorCauseParameter& other);
    virtual SCTPErrorCauseParameter *dup() const {return new SCTPErrorCauseParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32 responseCorrelationId);
    virtual uint32 getErrorCauseType() const;
    virtual void setErrorCauseType(uint32 errorCauseType);
};

inline void doPacking(cCommBuffer *b, SCTPErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:353</tt> by nedtool.
 * <pre>
 * message SCTPSimpleErrorCauseParameter extends SCTPParameter
 * {
 *     uint16 value;
 * }
 * </pre>
 */
class SCTPSimpleErrorCauseParameter : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint16 value_var;

  private:
    void copy(const SCTPSimpleErrorCauseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSimpleErrorCauseParameter&);

  public:
    SCTPSimpleErrorCauseParameter(const char *name=NULL, int kind=0);
    SCTPSimpleErrorCauseParameter(const SCTPSimpleErrorCauseParameter& other);
    virtual ~SCTPSimpleErrorCauseParameter();
    SCTPSimpleErrorCauseParameter& operator=(const SCTPSimpleErrorCauseParameter& other);
    virtual SCTPSimpleErrorCauseParameter *dup() const {return new SCTPSimpleErrorCauseParameter(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16 getValue() const;
    virtual void setValue(uint16 value);
};

inline void doPacking(cCommBuffer *b, SCTPSimpleErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPSimpleErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:358</tt> by nedtool.
 * <pre>
 * message SCTPSuccessIndication extends SCTPParameter
 * {
 *     uint32 responseCorrelationId;
 * }
 * </pre>
 */
class SCTPSuccessIndication : public ::inetveins::sctp::SCTPParameter
{
  protected:
    uint32 responseCorrelationId_var;

  private:
    void copy(const SCTPSuccessIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSuccessIndication&);

  public:
    SCTPSuccessIndication(const char *name=NULL, int kind=0);
    SCTPSuccessIndication(const SCTPSuccessIndication& other);
    virtual ~SCTPSuccessIndication();
    SCTPSuccessIndication& operator=(const SCTPSuccessIndication& other);
    virtual SCTPSuccessIndication *dup() const {return new SCTPSuccessIndication(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint32 getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32 responseCorrelationId);
};

inline void doPacking(cCommBuffer *b, SCTPSuccessIndication& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SCTPSuccessIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inetveins/transportlayer/sctp/SCTPMessage.msg:363</tt> by nedtool.
 * <pre>
 * message NatMessage extends cPacket
 * {
 *     bool multi;
 *     uint16 peer1;
 *     L3Address peer1Addresses[];
 *     uint32 portPeer1;
 *     uint16 peer2;
 *     L3Address peer2Addresses[];
 *     uint32 portPeer2;
 * }
 * </pre>
 */
class NatMessage : public ::cPacket
{
  protected:
    bool multi_var;
    uint16 peer1_var;
    L3Address *peer1Addresses_var; // array ptr
    unsigned int peer1Addresses_arraysize;
    uint32 portPeer1_var;
    uint16 peer2_var;
    L3Address *peer2Addresses_var; // array ptr
    unsigned int peer2Addresses_arraysize;
    uint32 portPeer2_var;

  private:
    void copy(const NatMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NatMessage&);

  public:
    NatMessage(const char *name=NULL, int kind=0);
    NatMessage(const NatMessage& other);
    virtual ~NatMessage();
    NatMessage& operator=(const NatMessage& other);
    virtual NatMessage *dup() const {return new NatMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getMulti() const;
    virtual void setMulti(bool multi);
    virtual uint16 getPeer1() const;
    virtual void setPeer1(uint16 peer1);
    virtual void setPeer1AddressesArraySize(unsigned int size);
    virtual unsigned int getPeer1AddressesArraySize() const;
    virtual L3Address& getPeer1Addresses(unsigned int k);
    virtual const L3Address& getPeer1Addresses(unsigned int k) const {return const_cast<NatMessage*>(this)->getPeer1Addresses(k);}
    virtual void setPeer1Addresses(unsigned int k, const L3Address& peer1Addresses);
    virtual uint32 getPortPeer1() const;
    virtual void setPortPeer1(uint32 portPeer1);
    virtual uint16 getPeer2() const;
    virtual void setPeer2(uint16 peer2);
    virtual void setPeer2AddressesArraySize(unsigned int size);
    virtual unsigned int getPeer2AddressesArraySize() const;
    virtual L3Address& getPeer2Addresses(unsigned int k);
    virtual const L3Address& getPeer2Addresses(unsigned int k) const {return const_cast<NatMessage*>(this)->getPeer2Addresses(k);}
    virtual void setPeer2Addresses(unsigned int k, const L3Address& peer2Addresses);
    virtual uint32 getPortPeer2() const;
    virtual void setPortPeer2(uint32 portPeer2);
};

inline void doPacking(cCommBuffer *b, NatMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NatMessage& obj) {obj.parsimUnpack(b);}

} // namespace sctp
} // namespace inetveins

#endif // ifndef _INETVEINS__SCTP_SCTPMESSAGE_M_H_

