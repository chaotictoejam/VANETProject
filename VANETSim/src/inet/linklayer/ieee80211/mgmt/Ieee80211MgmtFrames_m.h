//
// Generated file, do not edit! Created by nedtool 4.6 from linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg.
//

#ifndef _IEEE80211MGMTFRAMES_M_H_
#define _IEEE80211MGMTFRAMES_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "MACAddress.h"
#include "Ieee80211Frame_m.h"
#define PREQElemLen 11
#define PERRElemLen 13
// }}

/**
 * Struct generated from linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:41 by nedtool.
 */
struct Ieee80211CapabilityInformation
{
    Ieee80211CapabilityInformation();
    bool ESS;
    bool IBSS;
    bool CFPollable;
    bool CFPollRequest;
    bool privacy;
    bool DelayedBlockAck;
    bool InmediateBlockAck;
};

void doPacking(cCommBuffer *b, Ieee80211CapabilityInformation& a);
void doUnpacking(cCommBuffer *b, Ieee80211CapabilityInformation& a);

/**
 * Struct generated from linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:56 by nedtool.
 */
struct Ieee80211HandoverParameters
{
    Ieee80211HandoverParameters();
    double avgBackoffTime;
    double avgWaitTime;
    double avgErrorRate;
    double estAvailBW;
};

void doPacking(cCommBuffer *b, Ieee80211HandoverParameters& a);
void doUnpacking(cCommBuffer *b, Ieee80211HandoverParameters& a);

/**
 * Enum generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:67</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 reason code; values correspond to the standard.
 * //
 * enum Ieee80211ReasonCode
 * {
 * 
 *     RC_UNSPECIFIED = 1;
 *     RC_PREV_AUTH_EXPIRED = 2;
 *     RC_DEAUTH_MS_LEAVING = 3;
 *     RC_DISASS_INACTIVITY = 4;
 *     RC_DISASS_TOO_MANY_MS = 5;
 *     RC_NONAUTH_CLASS2 = 6;
 *     RC_NONASS_CLASS3 = 7;
 *     RC_DIASS_MS_LEAVING = 8;
 *     RC_NONAUTH_ASS_REQUEST = 9;
 *     RC_MESH_PEERING_CANCELLED = 52;
 *     RC_MESH_MAX_PEERS = 53;
 *     RC_MESH_CONFIGURATION_POLICY_VIOLATION = 54;
 *     RC_MESH_CLOSE_RCVD = 55;
 *     RC_MESH_MAX_RETRIES = 56;
 *     RC_MESH_CONFIRM_TIMEOUT = 57;
 *     RC_MESH_INVALID_GTK = 58;
 *     RC_MESH_INCONSISTENT_PARAMETERS = 59;
 *     RC_MESH_INVALID_SECURITY_CAPABILITY = 60;
 *     RC_MESH_PATH_ERROR_NO_PROXY_INFORMATION = 61;
 *     RC_MESH_PATH_ERROR_NO_FORWARDING_INFORMATION = 60;
 *     RC_MESH_PATH_ERROR_DESTINATION_UNREACHABLE = 63;
 *     RC_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS = 64;
 *     RC_MESH_CHANNEL_SWITCH_REGULATORY_REQUIREMENTS = 65;
 *     RC_MESH_CHANNEL_SWITCH_UNSPECIFIED = 66;
 * }
 * </pre>
 */
enum Ieee80211ReasonCode {
    RC_UNSPECIFIED = 1,
    RC_PREV_AUTH_EXPIRED = 2,
    RC_DEAUTH_MS_LEAVING = 3,
    RC_DISASS_INACTIVITY = 4,
    RC_DISASS_TOO_MANY_MS = 5,
    RC_NONAUTH_CLASS2 = 6,
    RC_NONASS_CLASS3 = 7,
    RC_DIASS_MS_LEAVING = 8,
    RC_NONAUTH_ASS_REQUEST = 9,
    RC_MESH_PEERING_CANCELLED = 52,
    RC_MESH_MAX_PEERS = 53,
    RC_MESH_CONFIGURATION_POLICY_VIOLATION = 54,
    RC_MESH_CLOSE_RCVD = 55,
    RC_MESH_MAX_RETRIES = 56,
    RC_MESH_CONFIRM_TIMEOUT = 57,
    RC_MESH_INVALID_GTK = 58,
    RC_MESH_INCONSISTENT_PARAMETERS = 59,
    RC_MESH_INVALID_SECURITY_CAPABILITY = 60,
    RC_MESH_PATH_ERROR_NO_PROXY_INFORMATION = 61,
    RC_MESH_PATH_ERROR_NO_FORWARDING_INFORMATION = 60,
    RC_MESH_PATH_ERROR_DESTINATION_UNREACHABLE = 63,
    RC_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS = 64,
    RC_MESH_CHANNEL_SWITCH_REGULATORY_REQUIREMENTS = 65,
    RC_MESH_CHANNEL_SWITCH_UNSPECIFIED = 66
};

/**
 * Enum generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:99</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 status code; values correspond to the standard.
 * //
 * enum Ieee80211StatusCode
 * {
 * 
 *     SC_SUCCESSFUL = 0;
 *     SC_UNSPECIFIED = 1;
 *     SC_UNSUP_CAP = 10;
 *     SC_REASS_DENIED = 11;
 *     SC_ASS_DENIED_UNKNOWN = 12;
 *     SC_AUTH_ALG0_UNSUP = 13;
 *     SC_AUTH_OUT_OF_SEQ = 14;
 *     SC_AUTH_CHALLENGE_FAIL = 15;
 *     SC_AUTH_TIMEOUT = 16;
 *     SC_ASS_TOO_MANY_MS = 17;
 *     SC_DATARATE_UNSUP = 18;
 *     SC_AUTH_REJECT_ANTI_CLOGING = 76;
 *     SC_AUTH_REJECT_FINITE_CYC_GROUP_UNS = 77;
 *     SC_TBTT_REQUEST = 78;
 * }
 * </pre>
 */
enum Ieee80211StatusCode {
    SC_SUCCESSFUL = 0,
    SC_UNSPECIFIED = 1,
    SC_UNSUP_CAP = 10,
    SC_REASS_DENIED = 11,
    SC_ASS_DENIED_UNKNOWN = 12,
    SC_AUTH_ALG0_UNSUP = 13,
    SC_AUTH_OUT_OF_SEQ = 14,
    SC_AUTH_CHALLENGE_FAIL = 15,
    SC_AUTH_TIMEOUT = 16,
    SC_ASS_TOO_MANY_MS = 17,
    SC_DATARATE_UNSUP = 18,
    SC_AUTH_REJECT_ANTI_CLOGING = 76,
    SC_AUTH_REJECT_FINITE_CYC_GROUP_UNS = 77,
    SC_TBTT_REQUEST = 78
};

/**
 * Enum generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:118</tt> by nedtool.
 * <pre>
 * enum Ieee80211HWMPCode
 * {
 * 
 *     IE11S_GANN = 125;
 *     IE11S_RANN = 126;
 *     IE11S_PREQ = 130;
 *     IE11S_PREP = 131;
 *     IE11S_PERR = 132;
 * }
 * </pre>
 */
enum Ieee80211HWMPCode {
    IE11S_GANN = 125,
    IE11S_RANN = 126,
    IE11S_PREQ = 130,
    IE11S_PREP = 131,
    IE11S_PERR = 132
};

/**
 * Struct generated from linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:130 by nedtool.
 */
struct Ieee80211SupportedRatesElement
{
    Ieee80211SupportedRatesElement();
    short numRates;
    double rate[8];
};

void doPacking(cCommBuffer *b, Ieee80211SupportedRatesElement& a);
void doUnpacking(cCommBuffer *b, Ieee80211SupportedRatesElement& a);

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:139</tt> by nedtool.
 * <pre>
 * //
 * // Frame body base class used to hide various frame body types
 * //
 * class Ieee80211FrameBody
 * {
 *     short bodyLength; // not an actual frame field
 * }
 * </pre>
 */
class Ieee80211FrameBody : public ::cObject
{
  protected:
    short bodyLength_var;

  private:
    void copy(const Ieee80211FrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211FrameBody&);

  public:
    Ieee80211FrameBody();
    Ieee80211FrameBody(const Ieee80211FrameBody& other);
    virtual ~Ieee80211FrameBody();
    Ieee80211FrameBody& operator=(const Ieee80211FrameBody& other);
    virtual Ieee80211FrameBody *dup() const {return new Ieee80211FrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getBodyLength() const;
    virtual void setBodyLength(short bodyLength);
};

inline void doPacking(cCommBuffer *b, Ieee80211FrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211FrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:154</tt> by nedtool.
 * <pre>
 * //
 * // Authentication frame body format.
 * //
 * // Note: the "isLast" field is not part of the standard.
 * // The authentication procedure is simulated by this model by exchanging
 * // a number of "dummy" authentication frames without real contents;
 * // the "isLast" field gets set by the AP to signal the STA that
 * // the authentication procedure has completed and it does not need to
 * // send any more Authentication frames.
 * //
 * class Ieee80211AuthenticationFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 6; // add 2+len bytes for challenge text if present
 *     unsigned short sequenceNumber;
 *     int statusCode @enum(Ieee80211StatusCode);
 *     bool isLast; // not part of the standard; see above
 * }
 * </pre>
 */
class Ieee80211AuthenticationFrameBody : public ::Ieee80211FrameBody
{
  protected:
    unsigned short sequenceNumber_var;
    int statusCode_var;
    bool isLast_var;

  private:
    void copy(const Ieee80211AuthenticationFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AuthenticationFrameBody&);

  public:
    Ieee80211AuthenticationFrameBody();
    Ieee80211AuthenticationFrameBody(const Ieee80211AuthenticationFrameBody& other);
    virtual ~Ieee80211AuthenticationFrameBody();
    Ieee80211AuthenticationFrameBody& operator=(const Ieee80211AuthenticationFrameBody& other);
    virtual Ieee80211AuthenticationFrameBody *dup() const {return new Ieee80211AuthenticationFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned short sequenceNumber);
    virtual int getStatusCode() const;
    virtual void setStatusCode(int statusCode);
    virtual bool getIsLast() const;
    virtual void setIsLast(bool isLast);
};

inline void doPacking(cCommBuffer *b, Ieee80211AuthenticationFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AuthenticationFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:165</tt> by nedtool.
 * <pre>
 * //
 * // De-authentication frame body format
 * //
 * class Ieee80211DeauthenticationFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 2;
 *     int reasonCode @enum(Ieee80211ReasonCode);
 * }
 * </pre>
 */
class Ieee80211DeauthenticationFrameBody : public ::Ieee80211FrameBody
{
  protected:
    int reasonCode_var;

  private:
    void copy(const Ieee80211DeauthenticationFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DeauthenticationFrameBody&);

  public:
    Ieee80211DeauthenticationFrameBody();
    Ieee80211DeauthenticationFrameBody(const Ieee80211DeauthenticationFrameBody& other);
    virtual ~Ieee80211DeauthenticationFrameBody();
    Ieee80211DeauthenticationFrameBody& operator=(const Ieee80211DeauthenticationFrameBody& other);
    virtual Ieee80211DeauthenticationFrameBody *dup() const {return new Ieee80211DeauthenticationFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getReasonCode() const;
    virtual void setReasonCode(int reasonCode);
};

inline void doPacking(cCommBuffer *b, Ieee80211DeauthenticationFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DeauthenticationFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:174</tt> by nedtool.
 * <pre>
 * //
 * // Dis-association frame body format (same as De-authentication)
 * //
 * class Ieee80211DisassociationFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 2;
 *     int reasonCode @enum(Ieee80211ReasonCode);
 * }
 * </pre>
 */
class Ieee80211DisassociationFrameBody : public ::Ieee80211FrameBody
{
  protected:
    int reasonCode_var;

  private:
    void copy(const Ieee80211DisassociationFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DisassociationFrameBody&);

  public:
    Ieee80211DisassociationFrameBody();
    Ieee80211DisassociationFrameBody(const Ieee80211DisassociationFrameBody& other);
    virtual ~Ieee80211DisassociationFrameBody();
    Ieee80211DisassociationFrameBody& operator=(const Ieee80211DisassociationFrameBody& other);
    virtual Ieee80211DisassociationFrameBody *dup() const {return new Ieee80211DisassociationFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getReasonCode() const;
    virtual void setReasonCode(int reasonCode);
};

inline void doPacking(cCommBuffer *b, Ieee80211DisassociationFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DisassociationFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:183</tt> by nedtool.
 * <pre>
 * //
 * // Probe request frame body format
 * //
 * class Ieee80211ProbeRequestFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 12; // assuming a 8-character SSID
 *     string SSID;
 *     Ieee80211SupportedRatesElement supportedRates;
 * }
 * </pre>
 */
class Ieee80211ProbeRequestFrameBody : public ::Ieee80211FrameBody
{
  protected:
    opp_string SSID_var;
    Ieee80211SupportedRatesElement supportedRates_var;

  private:
    void copy(const Ieee80211ProbeRequestFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeRequestFrameBody&);

  public:
    Ieee80211ProbeRequestFrameBody();
    Ieee80211ProbeRequestFrameBody(const Ieee80211ProbeRequestFrameBody& other);
    virtual ~Ieee80211ProbeRequestFrameBody();
    Ieee80211ProbeRequestFrameBody& operator=(const Ieee80211ProbeRequestFrameBody& other);
    virtual Ieee80211ProbeRequestFrameBody *dup() const {return new Ieee80211ProbeRequestFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getSSID() const;
    virtual void setSSID(const char * SSID);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211ProbeRequestFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeRequestFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeRequestFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:193</tt> by nedtool.
 * <pre>
 * //
 * // Association request frame body format
 * //
 * class Ieee80211AssociationRequestFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 16; // assuming a 8-character SSID
 *     string SSID;
 *     Ieee80211SupportedRatesElement supportedRates;
 * }
 * </pre>
 */
class Ieee80211AssociationRequestFrameBody : public ::Ieee80211FrameBody
{
  protected:
    opp_string SSID_var;
    Ieee80211SupportedRatesElement supportedRates_var;

  private:
    void copy(const Ieee80211AssociationRequestFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationRequestFrameBody&);

  public:
    Ieee80211AssociationRequestFrameBody();
    Ieee80211AssociationRequestFrameBody(const Ieee80211AssociationRequestFrameBody& other);
    virtual ~Ieee80211AssociationRequestFrameBody();
    Ieee80211AssociationRequestFrameBody& operator=(const Ieee80211AssociationRequestFrameBody& other);
    virtual Ieee80211AssociationRequestFrameBody *dup() const {return new Ieee80211AssociationRequestFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getSSID() const;
    virtual void setSSID(const char * SSID);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211AssociationRequestFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationRequestFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationRequestFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:203</tt> by nedtool.
 * <pre>
 * //
 * // Re-association request frame body format (same as association)
 * //
 * class Ieee80211ReassociationRequestFrameBody extends Ieee80211AssociationRequestFrameBody
 * {
 *     bodyLength = 26; // assuming a 8-character SSID and 4 supported datarates
 *     MACAddress currentAP;
 * }
 * </pre>
 */
class Ieee80211ReassociationRequestFrameBody : public ::Ieee80211AssociationRequestFrameBody
{
  protected:
    MACAddress currentAP_var;

  private:
    void copy(const Ieee80211ReassociationRequestFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationRequestFrameBody&);

  public:
    Ieee80211ReassociationRequestFrameBody();
    Ieee80211ReassociationRequestFrameBody(const Ieee80211ReassociationRequestFrameBody& other);
    virtual ~Ieee80211ReassociationRequestFrameBody();
    Ieee80211ReassociationRequestFrameBody& operator=(const Ieee80211ReassociationRequestFrameBody& other);
    virtual Ieee80211ReassociationRequestFrameBody *dup() const {return new Ieee80211ReassociationRequestFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddress& getCurrentAP();
    virtual const MACAddress& getCurrentAP() const {return const_cast<Ieee80211ReassociationRequestFrameBody*>(this)->getCurrentAP();}
    virtual void setCurrentAP(const MACAddress& currentAP);
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationRequestFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationRequestFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:212</tt> by nedtool.
 * <pre>
 * //
 * // Association response frame body format
 * //
 * class Ieee80211AssociationResponseFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 26; // assuming a 8-character SSID and 4 supported datarates
 *     int statusCode @enum(Ieee80211StatusCode);
 *     short aid;
 *     Ieee80211SupportedRatesElement supportedRates;
 * }
 * </pre>
 */
class Ieee80211AssociationResponseFrameBody : public ::Ieee80211FrameBody
{
  protected:
    int statusCode_var;
    short aid_var;
    Ieee80211SupportedRatesElement supportedRates_var;

  private:
    void copy(const Ieee80211AssociationResponseFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationResponseFrameBody&);

  public:
    Ieee80211AssociationResponseFrameBody();
    Ieee80211AssociationResponseFrameBody(const Ieee80211AssociationResponseFrameBody& other);
    virtual ~Ieee80211AssociationResponseFrameBody();
    Ieee80211AssociationResponseFrameBody& operator=(const Ieee80211AssociationResponseFrameBody& other);
    virtual Ieee80211AssociationResponseFrameBody *dup() const {return new Ieee80211AssociationResponseFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatusCode() const;
    virtual void setStatusCode(int statusCode);
    virtual short getAid() const;
    virtual void setAid(short aid);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211AssociationResponseFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationResponseFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationResponseFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:223</tt> by nedtool.
 * <pre>
 * //
 * // Re-association response frame body format (same as AssociationResponse)
 * //
 * class Ieee80211ReassociationResponseFrameBody extends Ieee80211AssociationResponseFrameBody
 * {
 * }
 * </pre>
 */
class Ieee80211ReassociationResponseFrameBody : public ::Ieee80211AssociationResponseFrameBody
{
  protected:

  private:
    void copy(const Ieee80211ReassociationResponseFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationResponseFrameBody&);

  public:
    Ieee80211ReassociationResponseFrameBody();
    Ieee80211ReassociationResponseFrameBody(const Ieee80211ReassociationResponseFrameBody& other);
    virtual ~Ieee80211ReassociationResponseFrameBody();
    Ieee80211ReassociationResponseFrameBody& operator=(const Ieee80211ReassociationResponseFrameBody& other);
    virtual Ieee80211ReassociationResponseFrameBody *dup() const {return new Ieee80211ReassociationResponseFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationResponseFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationResponseFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:230</tt> by nedtool.
 * <pre>
 * //
 * // Beacon frame body format.
 * //
 * class Ieee80211BeaconFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 50; // assuming a 8-character SSID, 4 supported datarate plus TIM
 *     string SSID;
 *     Ieee80211SupportedRatesElement supportedRates;
 *     simtime_t beaconInterval;
 *     int channelNumber;
 *     Ieee80211HandoverParameters handoverParameters;
 * }
 * </pre>
 */
class Ieee80211BeaconFrameBody : public ::Ieee80211FrameBody
{
  protected:
    opp_string SSID_var;
    Ieee80211SupportedRatesElement supportedRates_var;
    simtime_t beaconInterval_var;
    int channelNumber_var;
    Ieee80211HandoverParameters handoverParameters_var;

  private:
    void copy(const Ieee80211BeaconFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BeaconFrameBody&);

  public:
    Ieee80211BeaconFrameBody();
    Ieee80211BeaconFrameBody(const Ieee80211BeaconFrameBody& other);
    virtual ~Ieee80211BeaconFrameBody();
    Ieee80211BeaconFrameBody& operator=(const Ieee80211BeaconFrameBody& other);
    virtual Ieee80211BeaconFrameBody *dup() const {return new Ieee80211BeaconFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getSSID() const;
    virtual void setSSID(const char * SSID);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211BeaconFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
    virtual simtime_t getBeaconInterval() const;
    virtual void setBeaconInterval(simtime_t beaconInterval);
    virtual int getChannelNumber() const;
    virtual void setChannelNumber(int channelNumber);
    virtual Ieee80211HandoverParameters& getHandoverParameters();
    virtual const Ieee80211HandoverParameters& getHandoverParameters() const {return const_cast<Ieee80211BeaconFrameBody*>(this)->getHandoverParameters();}
    virtual void setHandoverParameters(const Ieee80211HandoverParameters& handoverParameters);
};

inline void doPacking(cCommBuffer *b, Ieee80211BeaconFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211BeaconFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:243</tt> by nedtool.
 * <pre>
 * //
 * // Probe response frame body format (same as Beacon)
 * //
 * class Ieee80211ProbeResponseFrameBody extends Ieee80211BeaconFrameBody
 * {
 * }
 * </pre>
 */
class Ieee80211ProbeResponseFrameBody : public ::Ieee80211BeaconFrameBody
{
  protected:

  private:
    void copy(const Ieee80211ProbeResponseFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeResponseFrameBody&);

  public:
    Ieee80211ProbeResponseFrameBody();
    Ieee80211ProbeResponseFrameBody(const Ieee80211ProbeResponseFrameBody& other);
    virtual ~Ieee80211ProbeResponseFrameBody();
    Ieee80211ProbeResponseFrameBody& operator=(const Ieee80211ProbeResponseFrameBody& other);
    virtual Ieee80211ProbeResponseFrameBody *dup() const {return new Ieee80211ProbeResponseFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeResponseFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeResponseFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:247</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionFrameBody extends Ieee80211FrameBody
 * {
 * }
 * </pre>
 */
class Ieee80211ActionFrameBody : public ::Ieee80211FrameBody
{
  protected:

  private:
    void copy(const Ieee80211ActionFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionFrameBody&);

  public:
    Ieee80211ActionFrameBody();
    Ieee80211ActionFrameBody(const Ieee80211ActionFrameBody& other);
    virtual ~Ieee80211ActionFrameBody();
    Ieee80211ActionFrameBody& operator=(const Ieee80211ActionFrameBody& other);
    virtual Ieee80211ActionFrameBody *dup() const {return new Ieee80211ActionFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:251</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionHWMPFrameBody extends Ieee80211ActionFrameBody
 * {
 *     int id @enum(Ieee80211HWMPCode);
 *     //unsigned char length;
 *     unsigned char flags = 0;
 *     unsigned char hopsCount = 0;
 *     unsigned char TTL = 32;
 * }
 * </pre>
 */
class Ieee80211ActionHWMPFrameBody : public ::Ieee80211ActionFrameBody
{
  protected:
    int id_var;
    unsigned char flags_var;
    unsigned char hopsCount_var;
    unsigned char TTL_var;

  private:
    void copy(const Ieee80211ActionHWMPFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionHWMPFrameBody&);

  public:
    Ieee80211ActionHWMPFrameBody();
    Ieee80211ActionHWMPFrameBody(const Ieee80211ActionHWMPFrameBody& other);
    virtual ~Ieee80211ActionHWMPFrameBody();
    Ieee80211ActionHWMPFrameBody& operator=(const Ieee80211ActionHWMPFrameBody& other);
    virtual Ieee80211ActionHWMPFrameBody *dup() const {return new Ieee80211ActionHWMPFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getId() const;
    virtual void setId(int id);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual unsigned char getHopsCount() const;
    virtual void setHopsCount(unsigned char hopsCount);
    virtual unsigned char getTTL() const;
    virtual void setTTL(unsigned char TTL);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionHWMPFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionHWMPFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:261 by nedtool.
 */
struct PREQElem
{
    PREQElem();
    bool TO;
    bool USN;
    MACAddress targetAddress;
    unsigned int targetSeqNumber;
};

void doPacking(cCommBuffer *b, PREQElem& a);
void doUnpacking(cCommBuffer *b, PREQElem& a);

/**
 * Struct generated from linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:269 by nedtool.
 */
struct PERRElem
{
    PERRElem();
    bool RC;
    bool AE;
    MACAddress destAddress;
    unsigned int destSeqNumber;
    unsigned int destExternalAddress;
    unsigned short reasonCode;
};

void doPacking(cCommBuffer *b, PERRElem& a);
void doUnpacking(cCommBuffer *b, PERRElem& a);

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:280</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionRANNFrameBody extends Ieee80211ActionHWMPFrameBody
 * {
 *     bodyLength = 23;
 *     id = IE11S_RANN;
 *     MACAddress root;
 *     unsigned int seqNumber;
 *     unsigned int interval;
 *     unsigned int metric = 0;
 * }
 * </pre>
 */
class Ieee80211ActionRANNFrameBody : public ::Ieee80211ActionHWMPFrameBody
{
  protected:
    MACAddress root_var;
    unsigned int seqNumber_var;
    unsigned int interval_var;
    unsigned int metric_var;

  private:
    void copy(const Ieee80211ActionRANNFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionRANNFrameBody&);

  public:
    Ieee80211ActionRANNFrameBody();
    Ieee80211ActionRANNFrameBody(const Ieee80211ActionRANNFrameBody& other);
    virtual ~Ieee80211ActionRANNFrameBody();
    Ieee80211ActionRANNFrameBody& operator=(const Ieee80211ActionRANNFrameBody& other);
    virtual Ieee80211ActionRANNFrameBody *dup() const {return new Ieee80211ActionRANNFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddress& getRoot();
    virtual const MACAddress& getRoot() const {return const_cast<Ieee80211ActionRANNFrameBody*>(this)->getRoot();}
    virtual void setRoot(const MACAddress& root);
    virtual unsigned int getSeqNumber() const;
    virtual void setSeqNumber(unsigned int seqNumber);
    virtual unsigned int getInterval() const;
    virtual void setInterval(unsigned int interval);
    virtual unsigned int getMetric() const;
    virtual void setMetric(unsigned int metric);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionRANNFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionRANNFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:290</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionPREQFrameBody extends Ieee80211ActionHWMPFrameBody
 * {
 *     bodyLength = 26;
 *     id = IE11S_PREQ;
 *     unsigned int pathDiscoveryId;
 *     MACAddress originator;
 *     unsigned int originatorSeqNumber;
 *     MACAddress originatorExternalAddr;
 *     unsigned int lifeTime;
 *     unsigned int metric = 0;
 *     unsigned char targetCount;
 *     PREQElem preqElem[];
 * }
 * </pre>
 */
class Ieee80211ActionPREQFrameBody : public ::Ieee80211ActionHWMPFrameBody
{
  protected:
    unsigned int pathDiscoveryId_var;
    MACAddress originator_var;
    unsigned int originatorSeqNumber_var;
    MACAddress originatorExternalAddr_var;
    unsigned int lifeTime_var;
    unsigned int metric_var;
    unsigned char targetCount_var;
    PREQElem *preqElem_var; // array ptr
    unsigned int preqElem_arraysize;

  private:
    void copy(const Ieee80211ActionPREQFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionPREQFrameBody&);

  public:
    Ieee80211ActionPREQFrameBody();
    Ieee80211ActionPREQFrameBody(const Ieee80211ActionPREQFrameBody& other);
    virtual ~Ieee80211ActionPREQFrameBody();
    Ieee80211ActionPREQFrameBody& operator=(const Ieee80211ActionPREQFrameBody& other);
    virtual Ieee80211ActionPREQFrameBody *dup() const {return new Ieee80211ActionPREQFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPathDiscoveryId() const;
    virtual void setPathDiscoveryId(unsigned int pathDiscoveryId);
    virtual MACAddress& getOriginator();
    virtual const MACAddress& getOriginator() const {return const_cast<Ieee80211ActionPREQFrameBody*>(this)->getOriginator();}
    virtual void setOriginator(const MACAddress& originator);
    virtual unsigned int getOriginatorSeqNumber() const;
    virtual void setOriginatorSeqNumber(unsigned int originatorSeqNumber);
    virtual MACAddress& getOriginatorExternalAddr();
    virtual const MACAddress& getOriginatorExternalAddr() const {return const_cast<Ieee80211ActionPREQFrameBody*>(this)->getOriginatorExternalAddr();}
    virtual void setOriginatorExternalAddr(const MACAddress& originatorExternalAddr);
    virtual unsigned int getLifeTime() const;
    virtual void setLifeTime(unsigned int lifeTime);
    virtual unsigned int getMetric() const;
    virtual void setMetric(unsigned int metric);
    virtual unsigned char getTargetCount() const;
    virtual void setTargetCount(unsigned char targetCount);
    virtual void setPreqElemArraySize(unsigned int size);
    virtual unsigned int getPreqElemArraySize() const;
    virtual PREQElem& getPreqElem(unsigned int k);
    virtual const PREQElem& getPreqElem(unsigned int k) const {return const_cast<Ieee80211ActionPREQFrameBody*>(this)->getPreqElem(k);}
    virtual void setPreqElem(unsigned int k, const PREQElem& preqElem);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionPREQFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionPREQFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:304</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionPREPFrameBody extends Ieee80211ActionHWMPFrameBody
 * {
 *     bodyLength = 37;
 *     id = IE11S_PREP;
 *     MACAddress target;
 *     unsigned int targetSeqNumber;
 *     MACAddress tagetExternalAddr;
 *     unsigned int lifeTime;
 *     unsigned int metric = 0;
 *     MACAddress originator;
 *     unsigned int originatorSeqNumber;
 * }
 * </pre>
 */
class Ieee80211ActionPREPFrameBody : public ::Ieee80211ActionHWMPFrameBody
{
  protected:
    MACAddress target_var;
    unsigned int targetSeqNumber_var;
    MACAddress tagetExternalAddr_var;
    unsigned int lifeTime_var;
    unsigned int metric_var;
    MACAddress originator_var;
    unsigned int originatorSeqNumber_var;

  private:
    void copy(const Ieee80211ActionPREPFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionPREPFrameBody&);

  public:
    Ieee80211ActionPREPFrameBody();
    Ieee80211ActionPREPFrameBody(const Ieee80211ActionPREPFrameBody& other);
    virtual ~Ieee80211ActionPREPFrameBody();
    Ieee80211ActionPREPFrameBody& operator=(const Ieee80211ActionPREPFrameBody& other);
    virtual Ieee80211ActionPREPFrameBody *dup() const {return new Ieee80211ActionPREPFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddress& getTarget();
    virtual const MACAddress& getTarget() const {return const_cast<Ieee80211ActionPREPFrameBody*>(this)->getTarget();}
    virtual void setTarget(const MACAddress& target);
    virtual unsigned int getTargetSeqNumber() const;
    virtual void setTargetSeqNumber(unsigned int targetSeqNumber);
    virtual MACAddress& getTagetExternalAddr();
    virtual const MACAddress& getTagetExternalAddr() const {return const_cast<Ieee80211ActionPREPFrameBody*>(this)->getTagetExternalAddr();}
    virtual void setTagetExternalAddr(const MACAddress& tagetExternalAddr);
    virtual unsigned int getLifeTime() const;
    virtual void setLifeTime(unsigned int lifeTime);
    virtual unsigned int getMetric() const;
    virtual void setMetric(unsigned int metric);
    virtual MACAddress& getOriginator();
    virtual const MACAddress& getOriginator() const {return const_cast<Ieee80211ActionPREPFrameBody*>(this)->getOriginator();}
    virtual void setOriginator(const MACAddress& originator);
    virtual unsigned int getOriginatorSeqNumber() const;
    virtual void setOriginatorSeqNumber(unsigned int originatorSeqNumber);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionPREPFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionPREPFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:317</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionPERRFrameBody extends Ieee80211ActionHWMPFrameBody
 * {
 *     bodyLength = 2;
 *     id = IE11S_PERR;
 *     unsigned char numDestination;
 *     PERRElem perrElem[];
 * }
 * </pre>
 */
class Ieee80211ActionPERRFrameBody : public ::Ieee80211ActionHWMPFrameBody
{
  protected:
    unsigned char numDestination_var;
    PERRElem *perrElem_var; // array ptr
    unsigned int perrElem_arraysize;

  private:
    void copy(const Ieee80211ActionPERRFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionPERRFrameBody&);

  public:
    Ieee80211ActionPERRFrameBody();
    Ieee80211ActionPERRFrameBody(const Ieee80211ActionPERRFrameBody& other);
    virtual ~Ieee80211ActionPERRFrameBody();
    Ieee80211ActionPERRFrameBody& operator=(const Ieee80211ActionPERRFrameBody& other);
    virtual Ieee80211ActionPERRFrameBody *dup() const {return new Ieee80211ActionPERRFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getNumDestination() const;
    virtual void setNumDestination(unsigned char numDestination);
    virtual void setPerrElemArraySize(unsigned int size);
    virtual unsigned int getPerrElemArraySize() const;
    virtual PERRElem& getPerrElem(unsigned int k);
    virtual const PERRElem& getPerrElem(unsigned int k) const {return const_cast<Ieee80211ActionPERRFrameBody*>(this)->getPerrElem(k);}
    virtual void setPerrElem(unsigned int k, const PERRElem& perrElem);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionPERRFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionPERRFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:325</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionGANNFrameBody extends Ieee80211ActionHWMPFrameBody
 * {
 *     bodyLength = 15;
 *     id = IE11S_GANN;
 *     MACAddress meshGateAddress;
 *     unsigned int meshGateSeqNumber;
 * 
 * }
 * //--------------------------------------------------------------
 * </pre>
 */
class Ieee80211ActionGANNFrameBody : public ::Ieee80211ActionHWMPFrameBody
{
  protected:
    MACAddress meshGateAddress_var;
    unsigned int meshGateSeqNumber_var;

  private:
    void copy(const Ieee80211ActionGANNFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionGANNFrameBody&);

  public:
    Ieee80211ActionGANNFrameBody();
    Ieee80211ActionGANNFrameBody(const Ieee80211ActionGANNFrameBody& other);
    virtual ~Ieee80211ActionGANNFrameBody();
    Ieee80211ActionGANNFrameBody& operator=(const Ieee80211ActionGANNFrameBody& other);
    virtual Ieee80211ActionGANNFrameBody *dup() const {return new Ieee80211ActionGANNFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddress& getMeshGateAddress();
    virtual const MACAddress& getMeshGateAddress() const {return const_cast<Ieee80211ActionGANNFrameBody*>(this)->getMeshGateAddress();}
    virtual void setMeshGateAddress(const MACAddress& meshGateAddress);
    virtual unsigned int getMeshGateSeqNumber() const;
    virtual void setMeshGateSeqNumber(unsigned int meshGateSeqNumber);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionGANNFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionGANNFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:339</tt> by nedtool.
 * <pre>
 * //
 * // Authentication frame format (management frame + body)
 * //
 * packet Ieee80211AuthenticationFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_AUTHENTICATION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211AuthenticationFrameBody body;
 * }
 * </pre>
 */
class Ieee80211AuthenticationFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211AuthenticationFrameBody body_var;

  private:
    void copy(const Ieee80211AuthenticationFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AuthenticationFrame&);

  public:
    Ieee80211AuthenticationFrame(const char *name=NULL, int kind=0);
    Ieee80211AuthenticationFrame(const Ieee80211AuthenticationFrame& other);
    virtual ~Ieee80211AuthenticationFrame();
    Ieee80211AuthenticationFrame& operator=(const Ieee80211AuthenticationFrame& other);
    virtual Ieee80211AuthenticationFrame *dup() const {return new Ieee80211AuthenticationFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211AuthenticationFrameBody& getBody();
    virtual const Ieee80211AuthenticationFrameBody& getBody() const {return const_cast<Ieee80211AuthenticationFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211AuthenticationFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211AuthenticationFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AuthenticationFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:349</tt> by nedtool.
 * <pre>
 * //
 * // De-authentication frame format (management frame + body)
 * //
 * packet Ieee80211DeauthenticationFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_DEAUTHENTICATION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211DeauthenticationFrameBody body;
 * }
 * </pre>
 */
class Ieee80211DeauthenticationFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211DeauthenticationFrameBody body_var;

  private:
    void copy(const Ieee80211DeauthenticationFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DeauthenticationFrame&);

  public:
    Ieee80211DeauthenticationFrame(const char *name=NULL, int kind=0);
    Ieee80211DeauthenticationFrame(const Ieee80211DeauthenticationFrame& other);
    virtual ~Ieee80211DeauthenticationFrame();
    Ieee80211DeauthenticationFrame& operator=(const Ieee80211DeauthenticationFrame& other);
    virtual Ieee80211DeauthenticationFrame *dup() const {return new Ieee80211DeauthenticationFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211DeauthenticationFrameBody& getBody();
    virtual const Ieee80211DeauthenticationFrameBody& getBody() const {return const_cast<Ieee80211DeauthenticationFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211DeauthenticationFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211DeauthenticationFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DeauthenticationFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:359</tt> by nedtool.
 * <pre>
 * //
 * // Dis-association frame format (management frame + body) (same as De-authentication)
 * //
 * packet Ieee80211DisassociationFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_DISASSOCIATION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211DisassociationFrameBody body;
 * }
 * </pre>
 */
class Ieee80211DisassociationFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211DisassociationFrameBody body_var;

  private:
    void copy(const Ieee80211DisassociationFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DisassociationFrame&);

  public:
    Ieee80211DisassociationFrame(const char *name=NULL, int kind=0);
    Ieee80211DisassociationFrame(const Ieee80211DisassociationFrame& other);
    virtual ~Ieee80211DisassociationFrame();
    Ieee80211DisassociationFrame& operator=(const Ieee80211DisassociationFrame& other);
    virtual Ieee80211DisassociationFrame *dup() const {return new Ieee80211DisassociationFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211DisassociationFrameBody& getBody();
    virtual const Ieee80211DisassociationFrameBody& getBody() const {return const_cast<Ieee80211DisassociationFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211DisassociationFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211DisassociationFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DisassociationFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:369</tt> by nedtool.
 * <pre>
 * //
 * // Probe request frame format (management frame + body)
 * //
 * packet Ieee80211ProbeRequestFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_PROBEREQUEST;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ProbeRequestFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ProbeRequestFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ProbeRequestFrameBody body_var;

  private:
    void copy(const Ieee80211ProbeRequestFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeRequestFrame&);

  public:
    Ieee80211ProbeRequestFrame(const char *name=NULL, int kind=0);
    Ieee80211ProbeRequestFrame(const Ieee80211ProbeRequestFrame& other);
    virtual ~Ieee80211ProbeRequestFrame();
    Ieee80211ProbeRequestFrame& operator=(const Ieee80211ProbeRequestFrame& other);
    virtual Ieee80211ProbeRequestFrame *dup() const {return new Ieee80211ProbeRequestFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ProbeRequestFrameBody& getBody();
    virtual const Ieee80211ProbeRequestFrameBody& getBody() const {return const_cast<Ieee80211ProbeRequestFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ProbeRequestFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeRequestFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeRequestFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:379</tt> by nedtool.
 * <pre>
 * //
 * // Association request frame format (management frame + body)
 * //
 * packet Ieee80211AssociationRequestFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ASSOCIATIONREQUEST;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211AssociationRequestFrameBody body;
 * }
 * </pre>
 */
class Ieee80211AssociationRequestFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211AssociationRequestFrameBody body_var;

  private:
    void copy(const Ieee80211AssociationRequestFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationRequestFrame&);

  public:
    Ieee80211AssociationRequestFrame(const char *name=NULL, int kind=0);
    Ieee80211AssociationRequestFrame(const Ieee80211AssociationRequestFrame& other);
    virtual ~Ieee80211AssociationRequestFrame();
    Ieee80211AssociationRequestFrame& operator=(const Ieee80211AssociationRequestFrame& other);
    virtual Ieee80211AssociationRequestFrame *dup() const {return new Ieee80211AssociationRequestFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211AssociationRequestFrameBody& getBody();
    virtual const Ieee80211AssociationRequestFrameBody& getBody() const {return const_cast<Ieee80211AssociationRequestFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211AssociationRequestFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationRequestFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationRequestFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:389</tt> by nedtool.
 * <pre>
 * //
 * // Re-association request frame format (management frame + body) (same as association)
 * //
 * packet Ieee80211ReassociationRequestFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_REASSOCIATIONREQUEST;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ReassociationRequestFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ReassociationRequestFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ReassociationRequestFrameBody body_var;

  private:
    void copy(const Ieee80211ReassociationRequestFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationRequestFrame&);

  public:
    Ieee80211ReassociationRequestFrame(const char *name=NULL, int kind=0);
    Ieee80211ReassociationRequestFrame(const Ieee80211ReassociationRequestFrame& other);
    virtual ~Ieee80211ReassociationRequestFrame();
    Ieee80211ReassociationRequestFrame& operator=(const Ieee80211ReassociationRequestFrame& other);
    virtual Ieee80211ReassociationRequestFrame *dup() const {return new Ieee80211ReassociationRequestFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ReassociationRequestFrameBody& getBody();
    virtual const Ieee80211ReassociationRequestFrameBody& getBody() const {return const_cast<Ieee80211ReassociationRequestFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ReassociationRequestFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationRequestFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationRequestFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:399</tt> by nedtool.
 * <pre>
 * //
 * // Association response frame format (management frame + body)
 * //
 * packet Ieee80211AssociationResponseFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ASSOCIATIONRESPONSE;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211AssociationResponseFrameBody body;
 * }
 * </pre>
 */
class Ieee80211AssociationResponseFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211AssociationResponseFrameBody body_var;

  private:
    void copy(const Ieee80211AssociationResponseFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationResponseFrame&);

  public:
    Ieee80211AssociationResponseFrame(const char *name=NULL, int kind=0);
    Ieee80211AssociationResponseFrame(const Ieee80211AssociationResponseFrame& other);
    virtual ~Ieee80211AssociationResponseFrame();
    Ieee80211AssociationResponseFrame& operator=(const Ieee80211AssociationResponseFrame& other);
    virtual Ieee80211AssociationResponseFrame *dup() const {return new Ieee80211AssociationResponseFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211AssociationResponseFrameBody& getBody();
    virtual const Ieee80211AssociationResponseFrameBody& getBody() const {return const_cast<Ieee80211AssociationResponseFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211AssociationResponseFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationResponseFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationResponseFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:409</tt> by nedtool.
 * <pre>
 * //
 * // Re-association response frame format (management frame + body)
 * //
 * packet Ieee80211ReassociationResponseFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_REASSOCIATIONRESPONSE;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ReassociationResponseFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ReassociationResponseFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ReassociationResponseFrameBody body_var;

  private:
    void copy(const Ieee80211ReassociationResponseFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationResponseFrame&);

  public:
    Ieee80211ReassociationResponseFrame(const char *name=NULL, int kind=0);
    Ieee80211ReassociationResponseFrame(const Ieee80211ReassociationResponseFrame& other);
    virtual ~Ieee80211ReassociationResponseFrame();
    Ieee80211ReassociationResponseFrame& operator=(const Ieee80211ReassociationResponseFrame& other);
    virtual Ieee80211ReassociationResponseFrame *dup() const {return new Ieee80211ReassociationResponseFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ReassociationResponseFrameBody& getBody();
    virtual const Ieee80211ReassociationResponseFrameBody& getBody() const {return const_cast<Ieee80211ReassociationResponseFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ReassociationResponseFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationResponseFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationResponseFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:419</tt> by nedtool.
 * <pre>
 * //
 * // Beacon frame format (management frame + body)
 * //
 * packet Ieee80211BeaconFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_BEACON;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211BeaconFrameBody body;
 * }
 * </pre>
 */
class Ieee80211BeaconFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211BeaconFrameBody body_var;

  private:
    void copy(const Ieee80211BeaconFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BeaconFrame&);

  public:
    Ieee80211BeaconFrame(const char *name=NULL, int kind=0);
    Ieee80211BeaconFrame(const Ieee80211BeaconFrame& other);
    virtual ~Ieee80211BeaconFrame();
    Ieee80211BeaconFrame& operator=(const Ieee80211BeaconFrame& other);
    virtual Ieee80211BeaconFrame *dup() const {return new Ieee80211BeaconFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211BeaconFrameBody& getBody();
    virtual const Ieee80211BeaconFrameBody& getBody() const {return const_cast<Ieee80211BeaconFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211BeaconFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211BeaconFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211BeaconFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:429</tt> by nedtool.
 * <pre>
 * //
 * // Probe response frame format (management frame + body); same as Beacon
 * //
 * packet Ieee80211ProbeResponseFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_PROBERESPONSE;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ProbeResponseFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ProbeResponseFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ProbeResponseFrameBody body_var;

  private:
    void copy(const Ieee80211ProbeResponseFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeResponseFrame&);

  public:
    Ieee80211ProbeResponseFrame(const char *name=NULL, int kind=0);
    Ieee80211ProbeResponseFrame(const Ieee80211ProbeResponseFrame& other);
    virtual ~Ieee80211ProbeResponseFrame();
    Ieee80211ProbeResponseFrame& operator=(const Ieee80211ProbeResponseFrame& other);
    virtual Ieee80211ProbeResponseFrame *dup() const {return new Ieee80211ProbeResponseFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ProbeResponseFrameBody& getBody();
    virtual const Ieee80211ProbeResponseFrameBody& getBody() const {return const_cast<Ieee80211ProbeResponseFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ProbeResponseFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeResponseFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeResponseFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:439</tt> by nedtool.
 * <pre>
 * //
 * // Action frames
 * //
 * packet Ieee80211ActionFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ActionFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionFrame : public ::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ActionFrameBody body_var;

  private:
    void copy(const Ieee80211ActionFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionFrame&);

  public:
    Ieee80211ActionFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionFrame(const Ieee80211ActionFrame& other);
    virtual ~Ieee80211ActionFrame();
    Ieee80211ActionFrame& operator=(const Ieee80211ActionFrame& other);
    virtual Ieee80211ActionFrame *dup() const {return new Ieee80211ActionFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionFrameBody& getBody();
    virtual const Ieee80211ActionFrameBody& getBody() const {return const_cast<Ieee80211ActionFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:449</tt> by nedtool.
 * <pre>
 * //
 * //  HWMP action frames
 * //
 * packet Ieee80211ActionHWMPFrame extends Ieee80211ActionFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *         // this fiels are used by fragmentation over ethernet, not necesasry, it's possible to use the fields un the Ieee80211 frame 
 *     bool isFragment = false;
 *     unsigned long realLength = 0;
 * 
 *     Ieee80211ActionHWMPFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionHWMPFrame : public ::Ieee80211ActionFrame
{
  protected:
    bool isFragment_var;
    unsigned long realLength_var;
    Ieee80211ActionHWMPFrameBody body_var;

  private:
    void copy(const Ieee80211ActionHWMPFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionHWMPFrame&);

  public:
    Ieee80211ActionHWMPFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionHWMPFrame(const Ieee80211ActionHWMPFrame& other);
    virtual ~Ieee80211ActionHWMPFrame();
    Ieee80211ActionHWMPFrame& operator=(const Ieee80211ActionHWMPFrame& other);
    virtual Ieee80211ActionHWMPFrame *dup() const {return new Ieee80211ActionHWMPFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getIsFragment() const;
    virtual void setIsFragment(bool isFragment);
    virtual unsigned long getRealLength() const;
    virtual void setRealLength(unsigned long realLength);
    virtual Ieee80211ActionHWMPFrameBody& getBody();
    virtual const Ieee80211ActionHWMPFrameBody& getBody() const {return const_cast<Ieee80211ActionHWMPFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionHWMPFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionHWMPFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionHWMPFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:461</tt> by nedtool.
 * <pre>
 * packet Ieee80211ActionRANNFrame extends Ieee80211ActionHWMPFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ActionRANNFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionRANNFrame : public ::Ieee80211ActionHWMPFrame
{
  protected:
    Ieee80211ActionRANNFrameBody body_var;

  private:
    void copy(const Ieee80211ActionRANNFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionRANNFrame&);

  public:
    Ieee80211ActionRANNFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionRANNFrame(const Ieee80211ActionRANNFrame& other);
    virtual ~Ieee80211ActionRANNFrame();
    Ieee80211ActionRANNFrame& operator=(const Ieee80211ActionRANNFrame& other);
    virtual Ieee80211ActionRANNFrame *dup() const {return new Ieee80211ActionRANNFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionRANNFrameBody& getBody();
    virtual const Ieee80211ActionRANNFrameBody& getBody() const {return const_cast<Ieee80211ActionRANNFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionRANNFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionRANNFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionRANNFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:468</tt> by nedtool.
 * <pre>
 * packet Ieee80211ActionPREQFrame extends Ieee80211ActionHWMPFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ActionPREQFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionPREQFrame : public ::Ieee80211ActionHWMPFrame
{
  protected:
    Ieee80211ActionPREQFrameBody body_var;

  private:
    void copy(const Ieee80211ActionPREQFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionPREQFrame&);

  public:
    Ieee80211ActionPREQFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionPREQFrame(const Ieee80211ActionPREQFrame& other);
    virtual ~Ieee80211ActionPREQFrame();
    Ieee80211ActionPREQFrame& operator=(const Ieee80211ActionPREQFrame& other);
    virtual Ieee80211ActionPREQFrame *dup() const {return new Ieee80211ActionPREQFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionPREQFrameBody& getBody();
    virtual const Ieee80211ActionPREQFrameBody& getBody() const {return const_cast<Ieee80211ActionPREQFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionPREQFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionPREQFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionPREQFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:476</tt> by nedtool.
 * <pre>
 * packet Ieee80211ActionPREPFrame extends Ieee80211ActionHWMPFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ActionPREPFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionPREPFrame : public ::Ieee80211ActionHWMPFrame
{
  protected:
    Ieee80211ActionPREPFrameBody body_var;

  private:
    void copy(const Ieee80211ActionPREPFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionPREPFrame&);

  public:
    Ieee80211ActionPREPFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionPREPFrame(const Ieee80211ActionPREPFrame& other);
    virtual ~Ieee80211ActionPREPFrame();
    Ieee80211ActionPREPFrame& operator=(const Ieee80211ActionPREPFrame& other);
    virtual Ieee80211ActionPREPFrame *dup() const {return new Ieee80211ActionPREPFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionPREPFrameBody& getBody();
    virtual const Ieee80211ActionPREPFrameBody& getBody() const {return const_cast<Ieee80211ActionPREPFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionPREPFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionPREPFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionPREPFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:483</tt> by nedtool.
 * <pre>
 * packet Ieee80211ActionPERRFrame extends Ieee80211ActionHWMPFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ActionPERRFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionPERRFrame : public ::Ieee80211ActionHWMPFrame
{
  protected:
    Ieee80211ActionPERRFrameBody body_var;

  private:
    void copy(const Ieee80211ActionPERRFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionPERRFrame&);

  public:
    Ieee80211ActionPERRFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionPERRFrame(const Ieee80211ActionPERRFrame& other);
    virtual ~Ieee80211ActionPERRFrame();
    Ieee80211ActionPERRFrame& operator=(const Ieee80211ActionPERRFrame& other);
    virtual Ieee80211ActionPERRFrame *dup() const {return new Ieee80211ActionPERRFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionPERRFrameBody& getBody();
    virtual const Ieee80211ActionPERRFrameBody& getBody() const {return const_cast<Ieee80211ActionPERRFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionPERRFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionPERRFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionPERRFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:491</tt> by nedtool.
 * <pre>
 * packet Ieee80211ActionGANNFrame extends Ieee80211ActionHWMPFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();
 *     Ieee80211ActionGANNFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionGANNFrame : public ::Ieee80211ActionHWMPFrame
{
  protected:
    Ieee80211ActionGANNFrameBody body_var;

  private:
    void copy(const Ieee80211ActionGANNFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionGANNFrame&);

  public:
    Ieee80211ActionGANNFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionGANNFrame(const Ieee80211ActionGANNFrame& other);
    virtual ~Ieee80211ActionGANNFrame();
    Ieee80211ActionGANNFrame& operator=(const Ieee80211ActionGANNFrame& other);
    virtual Ieee80211ActionGANNFrame *dup() const {return new Ieee80211ActionGANNFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionGANNFrameBody& getBody();
    virtual const Ieee80211ActionGANNFrameBody& getBody() const {return const_cast<Ieee80211ActionGANNFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionGANNFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionGANNFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionGANNFrame& obj) {obj.parsimUnpack(b);}


#endif // ifndef _IEEE80211MGMTFRAMES_M_H_

