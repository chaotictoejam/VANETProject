//
// Generated file, do not edit! Created by nedtool 4.6 from inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg.
//

#ifndef _INET__IEEE80211_IEEE80211MGMTFRAMES_M_H_
#define _INET__IEEE80211_IEEE80211MGMTFRAMES_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/linklayer/common/MACAddress.h"
#include "inet/linklayer/ieee80211/mac/Ieee80211Frame_m.h"
// }}


namespace inet {
namespace ieee80211 {

// cplusplus {{
#define PREQElemLen 11
#define PERRElemLen 13
// }}

/**
 * Struct generated from inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:45 by nedtool.
 */
struct Ieee80211CapabilityInformation
{
    Ieee80211CapabilityInformation();
    bool ESS;
    bool IBSS;
    bool CFPollable;
    bool CFPollRequest;
    bool privacy;
    bool DelayedBlockAck;
    bool InmediateBlockAck;
};

void doPacking(cCommBuffer *b, Ieee80211CapabilityInformation& a);
void doUnpacking(cCommBuffer *b, Ieee80211CapabilityInformation& a);

/**
 * Struct generated from inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:60 by nedtool.
 */
struct Ieee80211HandoverParameters
{
    Ieee80211HandoverParameters();
    double avgBackoffTime;
    double avgWaitTime;
    double avgErrorRate;
    double estAvailBW;
};

void doPacking(cCommBuffer *b, Ieee80211HandoverParameters& a);
void doUnpacking(cCommBuffer *b, Ieee80211HandoverParameters& a);

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:71</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 reason code; values correspond to the standard.
 * //
 * enum Ieee80211ReasonCode
 * {
 * 
 *     RC_UNSPECIFIED = 1;
 *     RC_PREV_AUTH_EXPIRED = 2;
 *     RC_DEAUTH_MS_LEAVING = 3;
 *     RC_DISASS_INACTIVITY = 4;
 *     RC_DISASS_TOO_MANY_MS = 5;
 *     RC_NONAUTH_CLASS2 = 6;
 *     RC_NONASS_CLASS3 = 7;
 *     RC_DIASS_MS_LEAVING = 8;
 *     RC_NONAUTH_ASS_REQUEST = 9;
 *     RC_MESH_PEERING_CANCELLED = 52;
 *     RC_MESH_MAX_PEERS = 53;
 *     RC_MESH_CONFIGURATION_POLICY_VIOLATION = 54;
 *     RC_MESH_CLOSE_RCVD = 55;
 *     RC_MESH_MAX_RETRIES = 56;
 *     RC_MESH_CONFIRM_TIMEOUT = 57;
 *     RC_MESH_INVALID_GTK = 58;
 *     RC_MESH_INCONSISTENT_PARAMETERS = 59;
 *     RC_MESH_INVALID_SECURITY_CAPABILITY = 60;
 *     RC_MESH_PATH_ERROR_NO_PROXY_INFORMATION = 61;
 *     RC_MESH_PATH_ERROR_NO_FORWARDING_INFORMATION = 60;
 *     RC_MESH_PATH_ERROR_DESTINATION_UNREACHABLE = 63;
 *     RC_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS = 64;
 *     RC_MESH_CHANNEL_SWITCH_REGULATORY_REQUIREMENTS = 65;
 *     RC_MESH_CHANNEL_SWITCH_UNSPECIFIED = 66;
 * }
 * </pre>
 */
enum Ieee80211ReasonCode {
    RC_UNSPECIFIED = 1,
    RC_PREV_AUTH_EXPIRED = 2,
    RC_DEAUTH_MS_LEAVING = 3,
    RC_DISASS_INACTIVITY = 4,
    RC_DISASS_TOO_MANY_MS = 5,
    RC_NONAUTH_CLASS2 = 6,
    RC_NONASS_CLASS3 = 7,
    RC_DIASS_MS_LEAVING = 8,
    RC_NONAUTH_ASS_REQUEST = 9,
    RC_MESH_PEERING_CANCELLED = 52,
    RC_MESH_MAX_PEERS = 53,
    RC_MESH_CONFIGURATION_POLICY_VIOLATION = 54,
    RC_MESH_CLOSE_RCVD = 55,
    RC_MESH_MAX_RETRIES = 56,
    RC_MESH_CONFIRM_TIMEOUT = 57,
    RC_MESH_INVALID_GTK = 58,
    RC_MESH_INCONSISTENT_PARAMETERS = 59,
    RC_MESH_INVALID_SECURITY_CAPABILITY = 60,
    RC_MESH_PATH_ERROR_NO_PROXY_INFORMATION = 61,
    RC_MESH_PATH_ERROR_NO_FORWARDING_INFORMATION = 60,
    RC_MESH_PATH_ERROR_DESTINATION_UNREACHABLE = 63,
    RC_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS = 64,
    RC_MESH_CHANNEL_SWITCH_REGULATORY_REQUIREMENTS = 65,
    RC_MESH_CHANNEL_SWITCH_UNSPECIFIED = 66
};

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:103</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 status code; values correspond to the standard.
 * //
 * enum Ieee80211StatusCode
 * {
 * 
 *     SC_SUCCESSFUL = 0;
 *     SC_UNSPECIFIED = 1;
 *     SC_UNSUP_CAP = 10;
 *     SC_REASS_DENIED = 11;
 *     SC_ASS_DENIED_UNKNOWN = 12;
 *     SC_AUTH_ALG0_UNSUP = 13;
 *     SC_AUTH_OUT_OF_SEQ = 14;
 *     SC_AUTH_CHALLENGE_FAIL = 15;
 *     SC_AUTH_TIMEOUT = 16;
 *     SC_ASS_TOO_MANY_MS = 17;
 *     SC_DATARATE_UNSUP = 18;
 *     SC_AUTH_REJECT_ANTI_CLOGING = 76;
 *     SC_AUTH_REJECT_FINITE_CYC_GROUP_UNS = 77;
 *     SC_TBTT_REQUEST = 78;
 * }
 * </pre>
 */
enum Ieee80211StatusCode {
    SC_SUCCESSFUL = 0,
    SC_UNSPECIFIED = 1,
    SC_UNSUP_CAP = 10,
    SC_REASS_DENIED = 11,
    SC_ASS_DENIED_UNKNOWN = 12,
    SC_AUTH_ALG0_UNSUP = 13,
    SC_AUTH_OUT_OF_SEQ = 14,
    SC_AUTH_CHALLENGE_FAIL = 15,
    SC_AUTH_TIMEOUT = 16,
    SC_ASS_TOO_MANY_MS = 17,
    SC_DATARATE_UNSUP = 18,
    SC_AUTH_REJECT_ANTI_CLOGING = 76,
    SC_AUTH_REJECT_FINITE_CYC_GROUP_UNS = 77,
    SC_TBTT_REQUEST = 78
};

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:122</tt> by nedtool.
 * <pre>
 * enum Ieee80211HWMPCode
 * {
 * 
 *     IE11S_GANN = 125;
 *     IE11S_RANN = 126;
 *     IE11S_PREQ = 130;
 *     IE11S_PREP = 131;
 *     IE11S_PERR = 132;
 * }
 * </pre>
 */
enum Ieee80211HWMPCode {
    IE11S_GANN = 125,
    IE11S_RANN = 126,
    IE11S_PREQ = 130,
    IE11S_PREP = 131,
    IE11S_PERR = 132
};

/**
 * Struct generated from inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:134 by nedtool.
 */
struct Ieee80211SupportedRatesElement
{
    Ieee80211SupportedRatesElement();
    short numRates;
    double rate[8];
};

void doPacking(cCommBuffer *b, Ieee80211SupportedRatesElement& a);
void doUnpacking(cCommBuffer *b, Ieee80211SupportedRatesElement& a);

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:143</tt> by nedtool.
 * <pre>
 * //
 * // Frame body base class used to hide various frame body types
 * //
 * class Ieee80211FrameBody
 * {
 *     short bodyLength; // not an actual frame field
 * }
 * </pre>
 */
class Ieee80211FrameBody : public ::cObject
{
  protected:
    short bodyLength_var;

  private:
    void copy(const Ieee80211FrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211FrameBody&);

  public:
    Ieee80211FrameBody();
    Ieee80211FrameBody(const Ieee80211FrameBody& other);
    virtual ~Ieee80211FrameBody();
    Ieee80211FrameBody& operator=(const Ieee80211FrameBody& other);
    virtual Ieee80211FrameBody *dup() const {return new Ieee80211FrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getBodyLength() const;
    virtual void setBodyLength(short bodyLength);
};

inline void doPacking(cCommBuffer *b, Ieee80211FrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211FrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:158</tt> by nedtool.
 * <pre>
 * //
 * // Authentication frame body format.
 * //
 * // Note: the "isLast" field is not part of the standard.
 * // The authentication procedure is simulated by this model by exchanging
 * // a number of "dummy" authentication frames without real contents;
 * // the "isLast" field gets set by the AP to signal the STA that
 * // the authentication procedure has completed and it does not need to
 * // send any more Authentication frames.
 * //
 * class Ieee80211AuthenticationFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 6; // add 2+len bytes for challenge text if present
 *     unsigned short sequenceNumber;
 *     int statusCode @enum(Ieee80211StatusCode);
 *     bool isLast; // not part of the standard; see above
 * }
 * </pre>
 */
class Ieee80211AuthenticationFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    unsigned short sequenceNumber_var;
    int statusCode_var;
    bool isLast_var;

  private:
    void copy(const Ieee80211AuthenticationFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AuthenticationFrameBody&);

  public:
    Ieee80211AuthenticationFrameBody();
    Ieee80211AuthenticationFrameBody(const Ieee80211AuthenticationFrameBody& other);
    virtual ~Ieee80211AuthenticationFrameBody();
    Ieee80211AuthenticationFrameBody& operator=(const Ieee80211AuthenticationFrameBody& other);
    virtual Ieee80211AuthenticationFrameBody *dup() const {return new Ieee80211AuthenticationFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned short sequenceNumber);
    virtual int getStatusCode() const;
    virtual void setStatusCode(int statusCode);
    virtual bool getIsLast() const;
    virtual void setIsLast(bool isLast);
};

inline void doPacking(cCommBuffer *b, Ieee80211AuthenticationFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AuthenticationFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:169</tt> by nedtool.
 * <pre>
 * //
 * // De-authentication frame body format
 * //
 * class Ieee80211DeauthenticationFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 2;
 *     int reasonCode @enum(Ieee80211ReasonCode);
 * }
 * </pre>
 */
class Ieee80211DeauthenticationFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    int reasonCode_var;

  private:
    void copy(const Ieee80211DeauthenticationFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DeauthenticationFrameBody&);

  public:
    Ieee80211DeauthenticationFrameBody();
    Ieee80211DeauthenticationFrameBody(const Ieee80211DeauthenticationFrameBody& other);
    virtual ~Ieee80211DeauthenticationFrameBody();
    Ieee80211DeauthenticationFrameBody& operator=(const Ieee80211DeauthenticationFrameBody& other);
    virtual Ieee80211DeauthenticationFrameBody *dup() const {return new Ieee80211DeauthenticationFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getReasonCode() const;
    virtual void setReasonCode(int reasonCode);
};

inline void doPacking(cCommBuffer *b, Ieee80211DeauthenticationFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DeauthenticationFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:178</tt> by nedtool.
 * <pre>
 * //
 * // Dis-association frame body format (same as De-authentication)
 * //
 * class Ieee80211DisassociationFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 2;
 *     int reasonCode @enum(Ieee80211ReasonCode);
 * }
 * </pre>
 */
class Ieee80211DisassociationFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    int reasonCode_var;

  private:
    void copy(const Ieee80211DisassociationFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DisassociationFrameBody&);

  public:
    Ieee80211DisassociationFrameBody();
    Ieee80211DisassociationFrameBody(const Ieee80211DisassociationFrameBody& other);
    virtual ~Ieee80211DisassociationFrameBody();
    Ieee80211DisassociationFrameBody& operator=(const Ieee80211DisassociationFrameBody& other);
    virtual Ieee80211DisassociationFrameBody *dup() const {return new Ieee80211DisassociationFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getReasonCode() const;
    virtual void setReasonCode(int reasonCode);
};

inline void doPacking(cCommBuffer *b, Ieee80211DisassociationFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DisassociationFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:187</tt> by nedtool.
 * <pre>
 * //
 * // Probe request frame body format
 * //
 * class Ieee80211ProbeRequestFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 12; // assuming a 8-character SSID     //FIXME bodyLength = 2 + length(SSID) + 2 + supportedRates.numRates
 *     string SSID;
 *     Ieee80211SupportedRatesElement supportedRates;
 * }
 * </pre>
 */
class Ieee80211ProbeRequestFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    opp_string SSID_var;
    Ieee80211SupportedRatesElement supportedRates_var;

  private:
    void copy(const Ieee80211ProbeRequestFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeRequestFrameBody&);

  public:
    Ieee80211ProbeRequestFrameBody();
    Ieee80211ProbeRequestFrameBody(const Ieee80211ProbeRequestFrameBody& other);
    virtual ~Ieee80211ProbeRequestFrameBody();
    Ieee80211ProbeRequestFrameBody& operator=(const Ieee80211ProbeRequestFrameBody& other);
    virtual Ieee80211ProbeRequestFrameBody *dup() const {return new Ieee80211ProbeRequestFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getSSID() const;
    virtual void setSSID(const char * SSID);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211ProbeRequestFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeRequestFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeRequestFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:197</tt> by nedtool.
 * <pre>
 * //
 * // Association request frame body format
 * //
 * class Ieee80211AssociationRequestFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 16; // assuming a 8-character SSID     //FIXME bodyLength = 2 + length(SSID) + 2 + supportedRates.numRates
 *     string SSID;
 *     Ieee80211SupportedRatesElement supportedRates;
 * }
 * </pre>
 */
class Ieee80211AssociationRequestFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    opp_string SSID_var;
    Ieee80211SupportedRatesElement supportedRates_var;

  private:
    void copy(const Ieee80211AssociationRequestFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationRequestFrameBody&);

  public:
    Ieee80211AssociationRequestFrameBody();
    Ieee80211AssociationRequestFrameBody(const Ieee80211AssociationRequestFrameBody& other);
    virtual ~Ieee80211AssociationRequestFrameBody();
    Ieee80211AssociationRequestFrameBody& operator=(const Ieee80211AssociationRequestFrameBody& other);
    virtual Ieee80211AssociationRequestFrameBody *dup() const {return new Ieee80211AssociationRequestFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getSSID() const;
    virtual void setSSID(const char * SSID);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211AssociationRequestFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationRequestFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationRequestFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:207</tt> by nedtool.
 * <pre>
 * //
 * // Re-association request frame body format (same as association)
 * //
 * class Ieee80211ReassociationRequestFrameBody extends Ieee80211AssociationRequestFrameBody
 * {
 *     bodyLength = 26; // assuming a 8-character SSID and 4 supported datarates     //FIXME bodyLength = 2 + length(SSID) + 2 + supportedRates.numRates + 2 + 6
 *     MACAddress currentAP;
 * }
 * </pre>
 */
class Ieee80211ReassociationRequestFrameBody : public ::inet::ieee80211::Ieee80211AssociationRequestFrameBody
{
  protected:
    MACAddress currentAP_var;

  private:
    void copy(const Ieee80211ReassociationRequestFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationRequestFrameBody&);

  public:
    Ieee80211ReassociationRequestFrameBody();
    Ieee80211ReassociationRequestFrameBody(const Ieee80211ReassociationRequestFrameBody& other);
    virtual ~Ieee80211ReassociationRequestFrameBody();
    Ieee80211ReassociationRequestFrameBody& operator=(const Ieee80211ReassociationRequestFrameBody& other);
    virtual Ieee80211ReassociationRequestFrameBody *dup() const {return new Ieee80211ReassociationRequestFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddress& getCurrentAP();
    virtual const MACAddress& getCurrentAP() const {return const_cast<Ieee80211ReassociationRequestFrameBody*>(this)->getCurrentAP();}
    virtual void setCurrentAP(const MACAddress& currentAP);
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationRequestFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationRequestFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:216</tt> by nedtool.
 * <pre>
 * //
 * // Association response frame body format
 * //
 * class Ieee80211AssociationResponseFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 26; // assuming a 8-character SSID and 4 supported datarates       //FIXME not a static value
 *     int statusCode @enum(Ieee80211StatusCode);
 *     short aid;
 *     Ieee80211SupportedRatesElement supportedRates;
 * }
 * </pre>
 */
class Ieee80211AssociationResponseFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    int statusCode_var;
    short aid_var;
    Ieee80211SupportedRatesElement supportedRates_var;

  private:
    void copy(const Ieee80211AssociationResponseFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationResponseFrameBody&);

  public:
    Ieee80211AssociationResponseFrameBody();
    Ieee80211AssociationResponseFrameBody(const Ieee80211AssociationResponseFrameBody& other);
    virtual ~Ieee80211AssociationResponseFrameBody();
    Ieee80211AssociationResponseFrameBody& operator=(const Ieee80211AssociationResponseFrameBody& other);
    virtual Ieee80211AssociationResponseFrameBody *dup() const {return new Ieee80211AssociationResponseFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatusCode() const;
    virtual void setStatusCode(int statusCode);
    virtual short getAid() const;
    virtual void setAid(short aid);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211AssociationResponseFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationResponseFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationResponseFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:227</tt> by nedtool.
 * <pre>
 * //
 * // Re-association response frame body format (same as AssociationResponse)
 * //
 * class Ieee80211ReassociationResponseFrameBody extends Ieee80211AssociationResponseFrameBody
 * {
 * }
 * </pre>
 */
class Ieee80211ReassociationResponseFrameBody : public ::inet::ieee80211::Ieee80211AssociationResponseFrameBody
{
  protected:

  private:
    void copy(const Ieee80211ReassociationResponseFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationResponseFrameBody&);

  public:
    Ieee80211ReassociationResponseFrameBody();
    Ieee80211ReassociationResponseFrameBody(const Ieee80211ReassociationResponseFrameBody& other);
    virtual ~Ieee80211ReassociationResponseFrameBody();
    Ieee80211ReassociationResponseFrameBody& operator=(const Ieee80211ReassociationResponseFrameBody& other);
    virtual Ieee80211ReassociationResponseFrameBody *dup() const {return new Ieee80211ReassociationResponseFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationResponseFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationResponseFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:234</tt> by nedtool.
 * <pre>
 * //
 * // Beacon frame body format.
 * //
 * class Ieee80211BeaconFrameBody extends Ieee80211FrameBody
 * {
 *     bodyLength = 50; // assuming a 8-character SSID, 4 supported datarate plus TIM     //FIXME bodyLength = 8 + 2 + 2 + (2 + length(SSID)) + (2 + supportedRates.numRates) + ???
 *     string SSID;
 *     Ieee80211SupportedRatesElement supportedRates;
 *     simtime_t beaconInterval;
 *     int channelNumber;
 *     Ieee80211HandoverParameters handoverParameters;     //TODO is it a vendor-specific parameter in serializer?
 * }
 * </pre>
 */
class Ieee80211BeaconFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:
    opp_string SSID_var;
    Ieee80211SupportedRatesElement supportedRates_var;
    simtime_t beaconInterval_var;
    int channelNumber_var;
    Ieee80211HandoverParameters handoverParameters_var;

  private:
    void copy(const Ieee80211BeaconFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BeaconFrameBody&);

  public:
    Ieee80211BeaconFrameBody();
    Ieee80211BeaconFrameBody(const Ieee80211BeaconFrameBody& other);
    virtual ~Ieee80211BeaconFrameBody();
    Ieee80211BeaconFrameBody& operator=(const Ieee80211BeaconFrameBody& other);
    virtual Ieee80211BeaconFrameBody *dup() const {return new Ieee80211BeaconFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getSSID() const;
    virtual void setSSID(const char * SSID);
    virtual Ieee80211SupportedRatesElement& getSupportedRates();
    virtual const Ieee80211SupportedRatesElement& getSupportedRates() const {return const_cast<Ieee80211BeaconFrameBody*>(this)->getSupportedRates();}
    virtual void setSupportedRates(const Ieee80211SupportedRatesElement& supportedRates);
    virtual simtime_t getBeaconInterval() const;
    virtual void setBeaconInterval(simtime_t beaconInterval);
    virtual int getChannelNumber() const;
    virtual void setChannelNumber(int channelNumber);
    virtual Ieee80211HandoverParameters& getHandoverParameters();
    virtual const Ieee80211HandoverParameters& getHandoverParameters() const {return const_cast<Ieee80211BeaconFrameBody*>(this)->getHandoverParameters();}
    virtual void setHandoverParameters(const Ieee80211HandoverParameters& handoverParameters);
};

inline void doPacking(cCommBuffer *b, Ieee80211BeaconFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211BeaconFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:247</tt> by nedtool.
 * <pre>
 * //
 * // Probe response frame body format (same as Beacon)
 * //
 * class Ieee80211ProbeResponseFrameBody extends Ieee80211BeaconFrameBody
 * {
 * }
 * </pre>
 */
class Ieee80211ProbeResponseFrameBody : public ::inet::ieee80211::Ieee80211BeaconFrameBody
{
  protected:

  private:
    void copy(const Ieee80211ProbeResponseFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeResponseFrameBody&);

  public:
    Ieee80211ProbeResponseFrameBody();
    Ieee80211ProbeResponseFrameBody(const Ieee80211ProbeResponseFrameBody& other);
    virtual ~Ieee80211ProbeResponseFrameBody();
    Ieee80211ProbeResponseFrameBody& operator=(const Ieee80211ProbeResponseFrameBody& other);
    virtual Ieee80211ProbeResponseFrameBody *dup() const {return new Ieee80211ProbeResponseFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeResponseFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeResponseFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:251</tt> by nedtool.
 * <pre>
 * class Ieee80211ActionFrameBody extends Ieee80211FrameBody
 * {
 * }
 * </pre>
 */
class Ieee80211ActionFrameBody : public ::inet::ieee80211::Ieee80211FrameBody
{
  protected:

  private:
    void copy(const Ieee80211ActionFrameBody& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionFrameBody&);

  public:
    Ieee80211ActionFrameBody();
    Ieee80211ActionFrameBody(const Ieee80211ActionFrameBody& other);
    virtual ~Ieee80211ActionFrameBody();
    Ieee80211ActionFrameBody& operator=(const Ieee80211ActionFrameBody& other);
    virtual Ieee80211ActionFrameBody *dup() const {return new Ieee80211ActionFrameBody(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionFrameBody& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionFrameBody& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:258</tt> by nedtool.
 * <pre>
 * //
 * // Authentication frame format (management frame + body)
 * //
 * packet Ieee80211AuthenticationFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_AUTHENTICATION;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211AuthenticationFrameBody body;
 * }
 * </pre>
 */
class Ieee80211AuthenticationFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211AuthenticationFrameBody body_var;

  private:
    void copy(const Ieee80211AuthenticationFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AuthenticationFrame&);

  public:
    Ieee80211AuthenticationFrame(const char *name=NULL, int kind=0);
    Ieee80211AuthenticationFrame(const Ieee80211AuthenticationFrame& other);
    virtual ~Ieee80211AuthenticationFrame();
    Ieee80211AuthenticationFrame& operator=(const Ieee80211AuthenticationFrame& other);
    virtual Ieee80211AuthenticationFrame *dup() const {return new Ieee80211AuthenticationFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211AuthenticationFrameBody& getBody();
    virtual const Ieee80211AuthenticationFrameBody& getBody() const {return const_cast<Ieee80211AuthenticationFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211AuthenticationFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211AuthenticationFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AuthenticationFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:268</tt> by nedtool.
 * <pre>
 * //
 * // De-authentication frame format (management frame + body)
 * //
 * packet Ieee80211DeauthenticationFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_DEAUTHENTICATION;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211DeauthenticationFrameBody body;
 * }
 * </pre>
 */
class Ieee80211DeauthenticationFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211DeauthenticationFrameBody body_var;

  private:
    void copy(const Ieee80211DeauthenticationFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DeauthenticationFrame&);

  public:
    Ieee80211DeauthenticationFrame(const char *name=NULL, int kind=0);
    Ieee80211DeauthenticationFrame(const Ieee80211DeauthenticationFrame& other);
    virtual ~Ieee80211DeauthenticationFrame();
    Ieee80211DeauthenticationFrame& operator=(const Ieee80211DeauthenticationFrame& other);
    virtual Ieee80211DeauthenticationFrame *dup() const {return new Ieee80211DeauthenticationFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211DeauthenticationFrameBody& getBody();
    virtual const Ieee80211DeauthenticationFrameBody& getBody() const {return const_cast<Ieee80211DeauthenticationFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211DeauthenticationFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211DeauthenticationFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DeauthenticationFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:278</tt> by nedtool.
 * <pre>
 * //
 * // Dis-association frame format (management frame + body) (same as De-authentication)
 * //
 * packet Ieee80211DisassociationFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_DISASSOCIATION;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211DisassociationFrameBody body;
 * }
 * </pre>
 */
class Ieee80211DisassociationFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211DisassociationFrameBody body_var;

  private:
    void copy(const Ieee80211DisassociationFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DisassociationFrame&);

  public:
    Ieee80211DisassociationFrame(const char *name=NULL, int kind=0);
    Ieee80211DisassociationFrame(const Ieee80211DisassociationFrame& other);
    virtual ~Ieee80211DisassociationFrame();
    Ieee80211DisassociationFrame& operator=(const Ieee80211DisassociationFrame& other);
    virtual Ieee80211DisassociationFrame *dup() const {return new Ieee80211DisassociationFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211DisassociationFrameBody& getBody();
    virtual const Ieee80211DisassociationFrameBody& getBody() const {return const_cast<Ieee80211DisassociationFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211DisassociationFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211DisassociationFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211DisassociationFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:288</tt> by nedtool.
 * <pre>
 * //
 * // Probe request frame format (management frame + body)
 * //
 * packet Ieee80211ProbeRequestFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_PROBEREQUEST;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211ProbeRequestFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ProbeRequestFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ProbeRequestFrameBody body_var;

  private:
    void copy(const Ieee80211ProbeRequestFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeRequestFrame&);

  public:
    Ieee80211ProbeRequestFrame(const char *name=NULL, int kind=0);
    Ieee80211ProbeRequestFrame(const Ieee80211ProbeRequestFrame& other);
    virtual ~Ieee80211ProbeRequestFrame();
    Ieee80211ProbeRequestFrame& operator=(const Ieee80211ProbeRequestFrame& other);
    virtual Ieee80211ProbeRequestFrame *dup() const {return new Ieee80211ProbeRequestFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ProbeRequestFrameBody& getBody();
    virtual const Ieee80211ProbeRequestFrameBody& getBody() const {return const_cast<Ieee80211ProbeRequestFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ProbeRequestFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeRequestFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeRequestFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:298</tt> by nedtool.
 * <pre>
 * //
 * // Association request frame format (management frame + body)
 * //
 * packet Ieee80211AssociationRequestFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ASSOCIATIONREQUEST;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211AssociationRequestFrameBody body;
 * }
 * </pre>
 */
class Ieee80211AssociationRequestFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211AssociationRequestFrameBody body_var;

  private:
    void copy(const Ieee80211AssociationRequestFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationRequestFrame&);

  public:
    Ieee80211AssociationRequestFrame(const char *name=NULL, int kind=0);
    Ieee80211AssociationRequestFrame(const Ieee80211AssociationRequestFrame& other);
    virtual ~Ieee80211AssociationRequestFrame();
    Ieee80211AssociationRequestFrame& operator=(const Ieee80211AssociationRequestFrame& other);
    virtual Ieee80211AssociationRequestFrame *dup() const {return new Ieee80211AssociationRequestFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211AssociationRequestFrameBody& getBody();
    virtual const Ieee80211AssociationRequestFrameBody& getBody() const {return const_cast<Ieee80211AssociationRequestFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211AssociationRequestFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationRequestFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationRequestFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:308</tt> by nedtool.
 * <pre>
 * //
 * // Re-association request frame format (management frame + body) (same as association)
 * //
 * packet Ieee80211ReassociationRequestFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_REASSOCIATIONREQUEST;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211ReassociationRequestFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ReassociationRequestFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ReassociationRequestFrameBody body_var;

  private:
    void copy(const Ieee80211ReassociationRequestFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationRequestFrame&);

  public:
    Ieee80211ReassociationRequestFrame(const char *name=NULL, int kind=0);
    Ieee80211ReassociationRequestFrame(const Ieee80211ReassociationRequestFrame& other);
    virtual ~Ieee80211ReassociationRequestFrame();
    Ieee80211ReassociationRequestFrame& operator=(const Ieee80211ReassociationRequestFrame& other);
    virtual Ieee80211ReassociationRequestFrame *dup() const {return new Ieee80211ReassociationRequestFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ReassociationRequestFrameBody& getBody();
    virtual const Ieee80211ReassociationRequestFrameBody& getBody() const {return const_cast<Ieee80211ReassociationRequestFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ReassociationRequestFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationRequestFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationRequestFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:318</tt> by nedtool.
 * <pre>
 * //
 * // Association response frame format (management frame + body)
 * //
 * packet Ieee80211AssociationResponseFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ASSOCIATIONRESPONSE;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211AssociationResponseFrameBody body;
 * }
 * </pre>
 */
class Ieee80211AssociationResponseFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211AssociationResponseFrameBody body_var;

  private:
    void copy(const Ieee80211AssociationResponseFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AssociationResponseFrame&);

  public:
    Ieee80211AssociationResponseFrame(const char *name=NULL, int kind=0);
    Ieee80211AssociationResponseFrame(const Ieee80211AssociationResponseFrame& other);
    virtual ~Ieee80211AssociationResponseFrame();
    Ieee80211AssociationResponseFrame& operator=(const Ieee80211AssociationResponseFrame& other);
    virtual Ieee80211AssociationResponseFrame *dup() const {return new Ieee80211AssociationResponseFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211AssociationResponseFrameBody& getBody();
    virtual const Ieee80211AssociationResponseFrameBody& getBody() const {return const_cast<Ieee80211AssociationResponseFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211AssociationResponseFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211AssociationResponseFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211AssociationResponseFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:328</tt> by nedtool.
 * <pre>
 * //
 * // Re-association response frame format (management frame + body)
 * //
 * packet Ieee80211ReassociationResponseFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_REASSOCIATIONRESPONSE;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211ReassociationResponseFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ReassociationResponseFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ReassociationResponseFrameBody body_var;

  private:
    void copy(const Ieee80211ReassociationResponseFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ReassociationResponseFrame&);

  public:
    Ieee80211ReassociationResponseFrame(const char *name=NULL, int kind=0);
    Ieee80211ReassociationResponseFrame(const Ieee80211ReassociationResponseFrame& other);
    virtual ~Ieee80211ReassociationResponseFrame();
    Ieee80211ReassociationResponseFrame& operator=(const Ieee80211ReassociationResponseFrame& other);
    virtual Ieee80211ReassociationResponseFrame *dup() const {return new Ieee80211ReassociationResponseFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ReassociationResponseFrameBody& getBody();
    virtual const Ieee80211ReassociationResponseFrameBody& getBody() const {return const_cast<Ieee80211ReassociationResponseFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ReassociationResponseFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ReassociationResponseFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ReassociationResponseFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:338</tt> by nedtool.
 * <pre>
 * //
 * // Beacon frame format (management frame + body)
 * //
 * packet Ieee80211BeaconFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_BEACON;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211BeaconFrameBody body;
 * }
 * </pre>
 */
class Ieee80211BeaconFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211BeaconFrameBody body_var;

  private:
    void copy(const Ieee80211BeaconFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BeaconFrame&);

  public:
    Ieee80211BeaconFrame(const char *name=NULL, int kind=0);
    Ieee80211BeaconFrame(const Ieee80211BeaconFrame& other);
    virtual ~Ieee80211BeaconFrame();
    Ieee80211BeaconFrame& operator=(const Ieee80211BeaconFrame& other);
    virtual Ieee80211BeaconFrame *dup() const {return new Ieee80211BeaconFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211BeaconFrameBody& getBody();
    virtual const Ieee80211BeaconFrameBody& getBody() const {return const_cast<Ieee80211BeaconFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211BeaconFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211BeaconFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211BeaconFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:348</tt> by nedtool.
 * <pre>
 * //
 * // Probe response frame format (management frame + body); same as Beacon
 * //
 * packet Ieee80211ProbeResponseFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_PROBERESPONSE;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211ProbeResponseFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ProbeResponseFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ProbeResponseFrameBody body_var;

  private:
    void copy(const Ieee80211ProbeResponseFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ProbeResponseFrame&);

  public:
    Ieee80211ProbeResponseFrame(const char *name=NULL, int kind=0);
    Ieee80211ProbeResponseFrame(const Ieee80211ProbeResponseFrame& other);
    virtual ~Ieee80211ProbeResponseFrame();
    Ieee80211ProbeResponseFrame& operator=(const Ieee80211ProbeResponseFrame& other);
    virtual Ieee80211ProbeResponseFrame *dup() const {return new Ieee80211ProbeResponseFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ProbeResponseFrameBody& getBody();
    virtual const Ieee80211ProbeResponseFrameBody& getBody() const {return const_cast<Ieee80211ProbeResponseFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ProbeResponseFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ProbeResponseFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ProbeResponseFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg:358</tt> by nedtool.
 * <pre>
 * //
 * // Action frames
 * //
 * packet Ieee80211ActionFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ACTION;
 *     byteLength = 28+getBody().getBodyLength();   //FIXME variable bodyLength
 *     Ieee80211ActionFrameBody body;
 * }
 * </pre>
 */
class Ieee80211ActionFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    Ieee80211ActionFrameBody body_var;

  private:
    void copy(const Ieee80211ActionFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionFrame&);

  public:
    Ieee80211ActionFrame(const char *name=NULL, int kind=0);
    Ieee80211ActionFrame(const Ieee80211ActionFrame& other);
    virtual ~Ieee80211ActionFrame();
    Ieee80211ActionFrame& operator=(const Ieee80211ActionFrame& other);
    virtual Ieee80211ActionFrame *dup() const {return new Ieee80211ActionFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Ieee80211ActionFrameBody& getBody();
    virtual const Ieee80211ActionFrameBody& getBody() const {return const_cast<Ieee80211ActionFrame*>(this)->getBody();}
    virtual void setBody(const Ieee80211ActionFrameBody& body);
};

inline void doPacking(cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimUnpack(b);}

} // namespace ieee80211
} // namespace inet

#endif // ifndef _INET__IEEE80211_IEEE80211MGMTFRAMES_M_H_

